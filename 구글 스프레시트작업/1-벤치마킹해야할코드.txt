/**
 * NonAuto_Utilities_Anchored_Complete.gs
 */

const AUTO_FMT = {
  ENABLED_SHEETS: ['Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à'],
  TARGET_COLUMN: 5,
  ANCHOR_TEXT: 'Ï§ëÏöîÎ≥¥Í≥†ÏÇ¨Ìï≠',
  TARGET_NAMED_RANGE: 'ÏûêÎèôÏÑúÏãù_ÎåÄÏÉÅ',
  EXCLUDE_NAMED_RANGE: 'ÏûêÎèôÏÑúÏãù_ÏòàÏô∏'
};

const PDF_EXPORT = {
  START_SHEET: 'Ïõî',
  END_SHEET_EXCLUSIVE: '4p',
  FILE_PREFIX: 'Î∞©ÏÜ°ÏóÖÎ¨¥ÏùºÏßÄ',
  FOLDER_ID: '',
  EXCLUDE_SHEETS: ['6p', 'ÏûÖÎ†•', 'Î©îÎ™®', 'memo'],
  EXCLUDE_NAMED_RANGE: '',
  EXCLUDE_NAME_REGEX: '',
  SKIP_EMPTY_SHEETS: false,
  IMAGE_RENDER_WAIT_MS: 4000
};

/* =========================
 * Í≥µÌÜµ Ìó¨Ìçº
 * ========================= */

function _isCellInRange_(rng, cell) {
  if (!rng) return false;
  if (rng.getSheet().getSheetId() !== cell.getSheet().getSheetId()) return false;
  return (
    cell.getRow() >= rng.getRow() &&
    cell.getRow() <= rng.getLastRow() &&
    cell.getColumn() >= rng.getColumn() &&
    cell.getColumn() <= rng.getLastColumn()
  );
}

function _findAnchorRowByText_(sheet, text) {
  if (!text) return null;
  const lastRow = Math.max(1, sheet.getLastRow());
  const lastCol = Math.max(1, Math.min(15, sheet.getLastColumn()));
  if (lastRow === 0) return null;
  const grid = sheet.getRange(1, 1, lastRow, lastCol).getDisplayValues();
  for (let r = 0; r < grid.length; r++) {
    for (let c = 0; c < grid[r].length; c++) {
      if (String(grid[r][c] || '').indexOf(text) !== -1) return r + 1;
    }
  }
  return null;
}

function sleepMs_(ms) {
  try {
    Utilities.sleep(ms);
  } catch (_) {}
}

function fetchPdfOrThrow_(url) {
  const token = ScriptApp.getOAuthToken();
  const res = UrlFetchApp.fetch(url, {
    headers: { Authorization: 'Bearer ' + token },
    muteHttpExceptions: true,
    followRedirects: true
  });
  const code = res.getResponseCode();
  const blob = res.getBlob();
  const headers = res.getHeaders();
  const ct = String(headers && headers['Content-Type'] ? headers['Content-Type'] : (blob.getContentType() || ''));
  const size = blob.getBytes().length;

  if (code !== 200) throw new Error('PDF ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå® - HTTP ' + code);

  const looksPdf = /application\/pdf/i.test(ct) || /\.pdf$/i.test(String(blob.getName() || ''));
  if (!looksPdf || size < 1024) {
    Logger.log('Unexpected PDF content: CT=' + ct + ', size=' + size + ', head=\n' + blob.getDataAsString().slice(0, 500));
    throw new Error('PDFÍ∞Ä ÏïÑÎãå ÏùëÎãµ ÎòêÎäî ÎπÑÏ†ïÏÉÅ ÌååÏùº(CT=' + ct + ', ' + size + 'B)');
  }
  return blob;
}

/* =========================
 * Ìè¥Îçî Ïú†Ìã∏
 * ========================= */

function _extractPureFolderId_(input) {
  if (!input) return null;
  const s = String(input).trim();

  let m = s.match(/\/folders\/([A-Za-z0-9_-]{10,})/);
  if (m && m[1]) return m[1];

  m = s.match(/[?&]id=([A-Za-z0-9_-]{10,})/);
  if (m && m[1]) return m[1];

  const cleaned = s.replace(/[?#].*$/, '');
  if (/^[A-Za-z0-9_-]{10,}$/.test(cleaned)) return cleaned;

  return null;
}

function _assertFolderReachable_(folderId) {
  const f = DriveApp.getFolderById(folderId);
  f.getName();
  f.getId();
  return f;
}

function _resolveTargetFolderOrFallback_(ss) {
  const ui = SpreadsheetApp.getUi();
  const raw = (PDF_EXPORT.FOLDER_ID || '').trim();

  if (raw) {
    const pureId = _extractPureFolderId_(raw);
    if (!pureId) {
      ui.alert(
        'Ìè¥Îçî ÏßÄÏ†ï Í≤ΩÍ≥†',
        'FOLDER_IDÏóêÏÑú ÏàúÏàò IDÎ•º Ï∂îÏ∂úÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.\nÏûÖÎ†•Í∞í: ' + raw + '\n‚Üí URL Ï†ÑÏ≤¥Í∞Ä ÏïÑÎãàÎùº, ÏàúÏàò Ìè¥Îçî IDÎßå ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.',
        ui.ButtonSet.OK
      );
    } else {
      try {
        return _assertFolderReachable_(pureId);
      } catch (e) {
        ui.alert('Ìè¥Îçî Ï†ëÍ∑º Î∂àÍ∞Ä', 'ÏßÄÏ†ï Ìè¥Îçî Ï†ëÍ∑ºÏóê Ïã§Ìå®ÌïòÏó¨ Í∏∞Î≥∏ ÏúÑÏπòÏóê Ï†ÄÏû•Ìï©ÎãàÎã§.\nÏÇ¨Ïú†: ' + e.message, ui.ButtonSet.OK);
      }
    }
  }

  const parents = DriveApp.getFileById(ss.getId()).getParents();
  return parents.hasNext() ? parents.next() : DriveApp.getRootFolder();
}

function testTargetFolderAccess() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const folder = _resolveTargetFolderOrFallback_(ss);
  const blob = Utilities.newBlob('folder-access-test', 'text/plain', 'access_test.txt');
  const f = folder.createFile(blob);
  f.setTrashed(true);
  SpreadsheetApp.getUi().alert('ÏßÄÏ†ï/Ìè¥Î∞± Ìè¥Îçî Ï†ëÍ∑º OK\nÌè¥ÎçîÎ™Ö: ' + folder.getName());
}

/* =========================
 * ÏãúÌä∏ Ìè¨Ìï®/Ï†úÏô∏ ÌåêÏ†ï
 * ========================= */

function getExcludedSheetNames_(ss) {
  const set = new Set();
  const base = (PDF_EXPORT.EXCLUDE_SHEETS || []).concat(['Î©îÎ™®', 'memo']);
  base.forEach(n => set.add(String(n).trim().toLowerCase()));

  const rn = PDF_EXPORT.EXCLUDE_NAMED_RANGE;
  if (rn && rn.trim() !== '') {
    const r = ss.getRangeByName(rn);
    if (r) {
      const vals = r.getDisplayValues();
      for (let i = 0; i < vals.length; i++) {
        for (let j = 0; j < vals[i].length; j++) {
          const v = String(vals[i][j]).trim().toLowerCase();
          if (v) set.add(v);
        }
      }
    }
  }
  return set;
}

function _containsMemoLike_(lowName) {
  if (lowName.indexOf('memo') !== -1) return true;
  if (lowName.replace(/\s+/g, '').indexOf('Î©îÎ™®') !== -1) return true;
  return false;
}

function shouldSkipSheetByNameString_(name) {
  const low = String(name || '').toLowerCase();
  if (_containsMemoLike_(low)) return true;
  if (low.indexOf('ÏûÖÎ†•') !== -1) return true;
  if (low === '6p' || low.indexOf('6p') === 0) return true;
  if (low.indexOf('4p') === 0 && low.indexOf('ÏûÖÎ†•') !== -1) return true;
  return false;
}

function shouldSkipSheet_(sheet, excludedSet) {
  const name = sheet.getName();
  const low = name.toLowerCase();

  if (shouldSkipSheetByNameString_(name)) return true;
  if (excludedSet.has(low)) return true;

  const pat = PDF_EXPORT.EXCLUDE_NAME_REGEX;
  if (pat && pat.trim() !== '') {
    try {
      if (new RegExp(pat).test(name)) return true;
    } catch (_) {}
  }

  if (PDF_EXPORT.SKIP_EMPTY_SHEETS) {
    const lr = Math.max(1, sheet.getLastRow());
    const lc = Math.max(1, sheet.getLastColumn());
    const grid = sheet.getRange(1, 1, lr, lc).getDisplayValues();
    let hasData = false;
    for (let r = 0; r < grid.length && !hasData; r++) {
      for (let c = 0; c < grid[r].length; c++) {
        if (String(grid[r][c]).trim() !== '') {
          hasData = true;
          break;
        }
      }
    }
    if (!hasData) return true;
  }
  return false;
}

function isWeekdaySheet_(name) {
  const low = String(name || '').toLowerCase();
  return (
    low.indexOf('Ïõî') === 0 ||
    low.indexOf('Ìôî') === 0 ||
    low.indexOf('Ïàò') === 0 ||
    low.indexOf('Î™©') === 0 ||
    low.indexOf('Í∏à') === 0
  );
}

function matchStart_(name) {
  const start = String(PDF_EXPORT.START_SHEET || '').toLowerCase();
  const low = String(name || '').toLowerCase();
  return start && low.indexOf(start) === 0;
}

function isEndMarker_(name) {
  const end = String(PDF_EXPORT.END_SHEET_EXCLUSIVE || '').toLowerCase();
  const low = String(name || '').toLowerCase();
  return end && low.indexOf(end) === 0;
}

/* =========================
 * Î©îÎâ¥ / Ïò®Î≥¥Îî©
 * ========================= */

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  showWelcomeIfFirstRun_();

  ui.createMenu('üõ†Ô∏è Ïú†Ìã∏Î¶¨Ìã∞')
    .addItem('ÏÑ†ÌÉù ÏòÅÏó≠ Í∏∞Ï§Ä ÌÖåÎëêÎ¶¨ Ï†ÅÏö©', 'applyExactMasterBorders')
    .addSeparator()
    .addItem('ÏÇ¨ÏßÑÏóÖÎ°úÎìú', 'automateFullImageProcess')
    .addSeparator()
    .addItem('Î≥∏Í¥ÄÏùºÏ†ïÏ†ïÎ†¨', 'sortBongwanSchedule')
    .addItem('Ïã†Í¥ÄÏùºÏ†ïÏ†ïÎ†¨', 'sortSingwanSchedule')
    .addSeparator()
    .addItem('ÏÑ†ÌÉùÏòÅÏó≠ ÌîΩÏÖÄ ÌôïÏù∏', 'getSelectionTotalSize')
    .addSeparator()
    .addItem('Ïù∏ÏáÑÏòÅÏó≠ Ïô∏ Ï≤≠ÏÜå', 'cleanOutsidePrintArea')
    .addSeparator()
    .addItem('ÏÇ¨Ï†ÑÏûëÏóÖ(IMAGE‚ÜíÏò§Î≤ÑÎ†àÏù¥ ÏπòÌôò)', 'replaceImageFunctionsOnActiveSheet_Overlay')
    .addItem('Ïõî~4p ÏÇ¨Ïù¥ PDF Ï†ÄÏû•', 'exportRangeToPdfBetweenMarkers')
    .addSeparator()
    .addItem('Íµ¨Í∏Ä ÎìúÎùºÏù¥Î∏å Ìè¥Îçî Ï†ëÍ∑º ÌÖåÏä§Ìä∏', 'testTargetFolderAccess')
    .addSeparator()
    .addItem('ÎèÑÏõÄÎßê', 'showUtilityHelp')
    .addToUi();
}

function showWelcomeIfFirstRun_() {
  const props = PropertiesService.getDocumentProperties();
  const shown = props.getProperty('UTIL_WELCOME_SHOWN_V2');
  if (shown === '1') return;

  SpreadsheetApp.getUi().alert(
    'üéâ ÏãúÌä∏ Í∏∞Îä• Ï≤´ ÏÇ¨Ïö© ÏïàÎÇ¥',
    'Ï≤òÏùå ÏÇ¨Ïö© Ïãú Í∂åÌïú ÏöîÏ≤≠ Ï∞ΩÏù¥ ÎÇòÌÉÄÎÇ©ÎãàÎã§. Ï†ïÏÉÅ ÎèôÏûëÏùÑ ÏúÑÌïú ÌïÑÏàò Í≥ºÏ†ïÏûÖÎãàÎã§.',
    SpreadsheetApp.getUi().ButtonSet.OK
  );
  props.setProperty('UTIL_WELCOME_SHOWN_V2', '1');
}

function showUtilityHelp() {
  const ui = SpreadsheetApp.getUi();
  const title = 'ÎèÑÏõÄÎßê';

  const intro = [
    'ÎÜçÌòëÎ∞©ÏÜ°Îã® - Î∞©ÏÜ°ÏóÖÎ¨¥ÏùºÏßÄ',
    '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'
  ];

  const utilityMenu = [
    '## üõ†Ô∏è Ïú†Ìã∏Î¶¨Ìã∞ Î©îÎâ¥',
    'Î©îÎâ¥ ‚Üí [üõ†Ô∏è Ïú†Ìã∏Î¶¨Ìã∞] ÌÅ¥Î¶≠ ÌõÑ Í∏∞Îä• ÏÇ¨Ïö© Í∞ÄÎä•',
    '',
    '‚Ä¢ Í∏∞Ï§Ä ÌÖåÎëêÎ¶¨ Ï†ÅÏö©: ÎØ∏Î¶¨ Ï†ïÌï¥ÏßÑ ÏñëÏãùÏùò ÌÖåÎëêÎ¶¨Î•º ÏÑ†ÌÉùÌïú ÏòÅÏó≠Ïóê Ìïú Î≤àÏóê Ï†ÅÏö©',
    '‚Ä¢ ÏÇ¨ÏßÑ ÏóÖÎ°úÎìú: Íµ¨Í∏Ä ÎìúÎùºÏù¥Î∏å ÎßÅÌÅ¨Îßå Î∂ôÏó¨ÎÑ£ÏúºÎ©¥ ÏãúÌä∏Ïóê ÏÇ¨ÏßÑÏù¥ ÏûêÎèô Ïó∞Îèô',
    '‚Ä¢ ÏùºÏ†ï Ï†ïÎ†¨: ÌöåÏùòÏã§ ÏãúÍ∞Ñ¬∑Ïû•ÏÜå Ïö∞ÏÑ†ÏàúÏúÑÏóê ÎßûÏ∂∞ ÏùºÏ†ïÏùÑ ÍπîÎÅîÌïòÍ≤å Ï†ïÎ†¨',
    '‚Ä¢ ÏÑ†ÌÉùÏòÅÏó≠(ÏÖÄ) ÌîΩÏÖÄ ÌôïÏù∏: ÏÑ†ÌÉù ÏÖÄÏùò Í∞ÄÎ°ú ÏÑ∏Î°ú ÌîΩÏÖÄ Ïàò ÌôïÏù∏',
    '‚Ä¢ Ïù∏ÏáÑ ÏòÅÏó≠ Ïô∏ Ï≤≠ÏÜå: Î∂àÌïÑÏöîÌïú ÏòÅÏó≠Ïùò Îç∞Ïù¥ÌÑ∞ÏôÄ ÏÑúÏãùÏùÑ Î™®Îëê ÏÇ≠Ï†úÌïòÏó¨ ÏãúÌä∏ Ï†ïÎ¶¨',
    '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'
  ];

  const autoInsert = [
    '## ‚ú® ÏûêÎèô ÌñâÏÇΩÏûÖ Í∏∞Îä•',
    'Ìëú Ï§ëÍ∞ÑÏóê ÏÉàÎ°úÏö¥ Ìñâ Ï∂îÍ∞Ä Ïãú, ÏÉàÎ°úÏö¥ ÌñâÏóê ÌÖåÎëêÎ¶¨ ÏûêÎèô Ï†ÅÏö©',
    '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ'
  ];

  const autoFormat = [
    '## ‚úçÔ∏è ÏûêÎèô ÏôÑÏÑ± Í∏∞Îä•',
    'ÏÖÄÏóê ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÎ©¥ ÌäπÏ†ï ÌÇ§ÏõåÎìúÏóê Îî∞Îùº ÏûêÎèôÏúºÎ°ú ÏÑúÏãùÏù¥ Ï†ÅÏö©',
    'Ï†ïÌôïÏÑ±ÏùÑ ÎÜíÏù¥Í∏∞ ÏúÑÌï¥ ( ) Í¥ÑÌò∏Î•º Ìè¨Ìï®Ìïú Îã®Ïñ¥Îßå Ï†ÅÏö©',
    '',
    '‚Ä¢ (ÌöåÏû•) Ìè¨Ìï® Ïãú ‚Üí Ìï¥Îãπ Ï§Ñ Ï†ÑÏ≤¥ ‚òÖ + ÍµµÍ≤å + Î∞ëÏ§Ñ',
    '  (Îã®, Î∂ÄÌöåÏû•, Í∏àÏúµÏßÄÏ£ºÌöåÏû•ÏùÄ Ï†úÏô∏)',
    '',
    '‚Ä¢ (Î∂ÄÌöåÏû•) Ìè¨Ìï® Ïãú ‚Üí Ìï¥Îãπ Ï§Ñ Ï†ÑÏ≤¥ ÍµµÍ≤å + Î∞ëÏ§Ñ',
    '',
    '‚Ä¢ (Í∏àÏúµÏßÄÏ£ºÌöåÏû•), (ÏùÄÌñâÏû•), (ÏÉÅÌò∏Í∏àÏúµÎåÄÌëú), (Ï∂ïÏÇ∞Í≤ΩÏ†úÎåÄÌëú), (ÎÜçÏóÖÍ≤ΩÏ†úÎåÄÌëú), (Í∞êÏÇ¨ÏúÑÏõêÏû•),(Ï°∞Ìï©Í∞êÏÇ¨ÏúÑÏõêÏû•),(Í≤ΩÏ†úÏßÄÏ£ºÎåÄÌëú) ‚Üí Ìï¥Îãπ Ï§Ñ Ï†ÑÏ≤¥ ÍµµÍ≤å',
    '',
    '‚Ä¢ Íµ≠ÎØºÏùòÎ°Ä, ÎÖπÏùå, ÎÖπÌôî ‚Üí Ìï¥Îãπ Îã®Ïñ¥Îßå ÍµµÍ≤å',
    '',
    '‚Ä¢ ÌöåÏùò ÎÇ¥Ïö©Ïù¥ Í∏∏ Îïå Ï§ÑÎ≥Ñ Ìè∞Ìä∏ ÌÅ¨Í∏∞Î•º Í∞úÎ≥Ñ Ï°∞Ï†ï Í∞ÄÎä•',
    '  (ÏÖÄ Ï†ÑÏ≤¥ ÏÑ†ÌÉù ÌõÑ Ìè∞Ìä∏ Î≥ÄÍ≤Ω Ïãú Í∞úÎ≥Ñ ÌÅ¨Í∏∞ Ï¥àÍ∏∞Ìôî)',
    '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ',
    '',
    '## üõ†Ô∏è PDF Ï†ÄÏû• Í∏∞Îä•',
    'PDF ÌååÏùºÎ°ú Ïõî~Í∏à ÏãúÌä∏ Î∞è ÏÇ¨ÏßÑ Ï†ÄÏû•',
    '‚Ä¢ ÏÇ¨Ï†ÑÏûëÏóÖ: IMAGE Ìï®Ïàò ‚Üí Ïò§Î≤ÑÎ†àÏù¥ Ïù¥ÎØ∏ÏßÄÎ°ú ÏπòÌôò(ÌòÑÏû¨ ÏãúÌä∏)',
    '‚Ä¢ Ïõî ÏãúÌä∏~4p ÏÇ¨Ïù¥ PDF Ï†ÄÏû•(ÌååÏùºÎ™Ö: Î∞©ÏÜ°ÏóÖÎ¨¥ÏùºÏßÄ(MM.DD~MM.DD).pdf)'
  ];

  const message = [...intro, '', ...utilityMenu, '', ...autoInsert, '', ...autoFormat].join('\n');
  ui.alert(title, message, ui.ButtonSet.OK);
}

/* =========================
 * Î≥¥Îçî Ïú†Ìã∏
 * ========================= */

const BORDER_PRIORITY = {
  DOTTED: 1,
  DASHED: 2,
  SOLID: 3,
  SOLID_MEDIUM: 4,
  SOLID_THICK: 5,
  DOUBLE: 6
};

function pickStrongerBorder(existingSide, incomingSide) {
  const hasExisting = !!existingSide;
  const hasIncoming = !!incomingSide;
  if (!hasExisting && !hasIncoming) return null;
  if (hasExisting && !hasIncoming) return existingSide;
  if (!hasExisting && hasIncoming) return incomingSide;

  const es = BORDER_PRIORITY[String((existingSide && existingSide.style) || '')] || 0;
  const ns = BORDER_PRIORITY[String((incomingSide && incomingSide.style) || '')] || 0;
  return es >= ns ? existingSide : incomingSide;
}

function mergeBordersCell(existing, incoming) {
  const out = {};
  const ex = existing || {};
  const inc = incoming || {};
  ['top', 'bottom', 'left', 'right'].forEach(s => {
    const chosen = pickStrongerBorder(ex[s] || null, inc[s] || null);
    if (chosen) out[s] = chosen;
  });
  return out;
}

/* =========================
 * Í∏∞Ï§Ä/Í∏∞Ï°¥ Î≥¥Îçî ÏùΩÍ∏∞
 * ========================= */

function MasterBorders_fetchPatternGrid_(ss) {
  try {
    const master = ss.getRangeByName('Í∏∞Ï§ÄÏÑúÏãù');
    if (!master) {
      SpreadsheetApp.getUi().alert(
        'Ïù¥Î¶ÑÎ≤îÏúÑ "Í∏∞Ï§ÄÏÑúÏãù"ÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.\nÏãúÏãùÏãúÌä∏!B8:G8ÏùÑ ÏßÄÏ†ïÌï¥ Ï£ºÏÑ∏Ïöî.',
        SpreadsheetApp.getUi().ButtonSet.OK
      );
      return null;
    }

    const res = Sheets.Spreadsheets.get(ss.getId(), {
      ranges: master.getSheet().getName() + '!' + master.getA1Notation(),
      fields: 'sheets.data.rowData.values.userEnteredFormat.borders'
    });

    const rows = master.getNumRows();
    const cols = master.getNumColumns();
    const rowData =
      res && res.sheets && res.sheets[0] && res.sheets[0].data && res.sheets[0].data[0]
        ? res.sheets[0].data[0].rowData || []
        : [];
    const grid = [];

    for (let r = 0; r < rows; r++) {
      const values = rowData[r] && rowData[r].values ? rowData[r].values : [];
      const line = [];
      for (let c = 0; c < cols; c++) {
        const fmt = values[c] && values[c].userEnteredFormat ? values[c].userEnteredFormat : {};
        line.push((fmt && fmt.borders) ? fmt.borders : {});
      }
      grid.push(line);
    }
    return { rows: rows, cols: cols, grid: grid };
  } catch (err) {
    Logger.log('[MasterBorders_fetchPatternGrid_] ' + (err.stack || err));
    return null;
  }
}

function fetchExistingBordersGrid_(sheet, range) {
  const ss = sheet.getParent();
  const res = Sheets.Spreadsheets.get(ss.getId(), {
    ranges: sheet.getName() + '!' + range.getA1Notation(),
    fields: 'sheets.data.rowData.values.userEnteredFormat.borders'
  });

  const rows = range.getNumRows();
  const cols = range.getNumColumns();
  const rowData =
    res && res.sheets && res.sheets[0] && res.sheets[0].data && res.sheets[0].data[0]
      ? res.sheets[0].data[0].rowData || []
      : [];
  const grid = [];

  for (let r = 0; r < rows; r++) {
    const values = rowData[r] && rowData[r].values ? rowData[r].values : [];
    const line = [];
    for (let c = 0; c < cols; c++) {
      const fmt = values[c] && values[c].userEnteredFormat ? values[c].userEnteredFormat : {};
      line.push((fmt && fmt.borders) ? fmt.borders : {});
    }
    grid.push(line);
  }
  return { rows: rows, cols: cols, grid: grid };
}

/* =========================
 * Í∏∞Ï§Ä ÌÖåÎëêÎ¶¨ Î≥µÏ†ú(ÏÑ†ÌÉùÏòÅÏó≠)
 * ========================= */

function applyExactMasterBorders() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const rng = sheet.getActiveRange();
  if (!rng) {
    ui.alert('ÏïåÎ¶º', 'Î®ºÏ†Ä ÌÖåÎëêÎ¶¨Î•º Ï†ÅÏö©Ìï† ÏòÅÏó≠ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.', ui.ButtonSet.OK);
    return;
  }

  const pattern = MasterBorders_fetchPatternGrid_(ss);
  if (!pattern) {
    ui.alert('ÏïåÎ¶º', 'Ïù¥Î¶ÑÎ≤îÏúÑ "Í∏∞Ï§ÄÏÑúÏãù"(ÏãúÏãùÏãúÌä∏!B8:G8)ÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.', ui.ButtonSet.OK);
    return;
  }

  const mergedRanges = rng.getMergedRanges();
  const mergedSnaps = snapshotMergedTopEdges_(sheet, mergedRanges);
  rng.breakApart();

  const mergedCoord = [];
  mergedRanges.forEach(r => {
    for (let rr = r.getRow(); rr < r.getRow() + r.getNumRows(); rr++) {
      for (let cc = r.getColumn(); cc < r.getColumn() + r.getNumColumns(); cc++) {
        mergedCoord.push(rr + ',' + cc);
      }
    }
  });

  const existing = fetchExistingBordersGrid_(sheet, rng);
  const sheetId = sheet.getSheetId();
  const sr = rng.getRow() - 1;
  const sc = rng.getColumn() - 1;
  const nr = rng.getNumRows();
  const nc = rng.getNumColumns();

  const requests = [];
  for (let r = 0; r < nr; r++) {
    for (let c = 0; c < nc; c++) {
      const pr = r % pattern.rows;
      const pc = c % pattern.cols;
      const baseExisting = existing.grid[r] && existing.grid[r][c] ? existing.grid[r][c] : {};
      const basePattern =
        pattern.grid[pr] && pattern.grid[pr][pc]
          ? pattern.grid[pr][pc]
          : {};
      const mergedBorders = mergeBordersCell(baseExisting, basePattern);

      const absRow = rng.getRow() + r;
      const absCol = rng.getColumn() + c;
      const inMerged = mergedCoord.indexOf(absRow + ',' + absCol) !== -1;

      const fields = inMerged
        ? buildBordersFieldsSkipTop_(mergedBorders)
        : buildBordersFields_(mergedBorders);
      if (!fields) continue;

      requests.push({
        updateCells: {
          range: {
            sheetId: sheetId,
            startRowIndex: sr + r,
            endRowIndex: sr + r + 1,
            startColumnIndex: sc + c,
            endColumnIndex: sc + c + 1
          },
          rows: [{ values: [{ userEnteredFormat: { borders: mergedBorders } }] }],
          fields: fields
        }
      });
    }
  }

  if (requests.length) {
    Sheets.Spreadsheets.batchUpdate({ requests: requests }, ss.getId());
  }

  mergedRanges.forEach(r => {
    sheet.getRange(r.getRow(), r.getColumn(), r.getNumRows(), r.getNumColumns()).merge();
  });

  if (mergedSnaps.length) {
    const fixRequests = [];
    mergedSnaps.forEach(s => {
      if (!s.top) return;
      fixRequests.push({
        updateBorders: {
          range: {
            sheetId: sheetId,
            startRowIndex: s.row - 1,
            endRowIndex: s.row - 1 + s.nr,
            startColumnIndex: s.col - 1,
            endColumnIndex: s.col - 1 + s.nc
          },
          top: s.top
        }
      });
    });
    if (fixRequests.length) {
      Sheets.Spreadsheets.batchUpdate({ requests: fixRequests }, ss.getId());
    }
  }
}

function buildBordersFields_(bordersObj) {
  if (!bordersObj) return '';
  const parts = [];
  if (bordersObj.top) parts.push('userEnteredFormat.borders.top');
  if (bordersObj.bottom) parts.push('userEnteredFormat.borders.bottom');
  if (bordersObj.left) parts.push('userEnteredFormat.borders.left');
  if (bordersObj.right) parts.push('userEnteredFormat.borders.right');
  return parts.length ? parts.join(',') : '';
}

function buildBordersFieldsSkipTop_(bordersObj) {
  if (!bordersObj) return '';
  const parts = [];
  if (bordersObj.bottom) parts.push('userEnteredFormat.borders.bottom');
  if (bordersObj.left) parts.push('userEnteredFormat.borders.left');
  if (bordersObj.right) parts.push('userEnteredFormat.borders.right');
  return parts.length ? parts.join(',') : '';
}

function snapshotMergedTopEdges_(sheet, mergedRanges) {
  const snaps = [];
  mergedRanges.forEach(r => {
    const row = r.getRow();
    const col = r.getColumn();
    const nr = r.getNumRows();
    const nc = r.getNumColumns();
    const grid = fetchExistingBordersGrid_(sheet, r).grid;
    const top = strongestTopOnGrid_(grid);
    snaps.push({ row: row, col: col, nr: nr, nc: nc, top: top });
  });
  return snaps;
}

function strongestTopOnGrid_(grid) {
  let chosen = null;
  const rows = grid.length;
  const cols = rows ? grid[0].length : 0;
  if (!rows || !cols) return null;
  for (let c = 0; c < cols; c++) {
    const cand = grid[0][c] && grid[0][c].top ? grid[0][c].top : null;
    chosen = pickStrongerBorder(chosen, cand);
  }
  return chosen;
}

/* =========================
 * ÏÑ†ÌÉù ÏòÅÏó≠ ÌÅ¨Í∏∞ ÌôïÏù∏
 * ========================= */

function getSelectionTotalSize() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const selection = sheet.getActiveRange();
  if (!selection) {
    ui.alert('ÏïåÎ¶º', 'Î®ºÏ†Ä ÌÅ¨Í∏∞Î•º ÌôïÏù∏Ìï† ÏÖÄ ÏòÅÏó≠ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.', ui.ButtonSet.OK);
    return;
  }

  const startRow = selection.getRow();
  const endRow = selection.getLastRow();
  const startCol = selection.getColumn();
  const endCol = selection.getLastColumn();

  let totalHeight = 0;
  for (let i = startRow; i <= endRow; i++) totalHeight += sheet.getRowHeight(i);

  let totalWidth = 0;
  for (let i = startCol; i <= endCol; i++) totalWidth += sheet.getColumnWidth(i);

  ui.alert(
    'ÏÑ†ÌÉù ÏòÅÏó≠ Ï¥ù ÌÅ¨Í∏∞',
    'ÎÜíÏù¥: ' + totalHeight + '\nÎÑàÎπÑ: ' + totalWidth,
    ui.ButtonSet.OK
  );
}

/* =========================
 * Ïù∏ÏáÑÏòÅÏó≠ Ïô∏Î∂Ä Ï≤≠ÏÜå
 * ========================= */

function cleanOutsidePrintArea() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const selection = sheet.getActiveRange();

  let protectedLastRow;
  let protectedLastCol;
  let rangeDescription;

  if (selection && (selection.getNumRows() > 1 || selection.getNumColumns() > 1)) {
    protectedLastRow = selection.getLastRow();
    protectedLastCol = selection.getLastColumn();
    rangeDescription = 'ÏÑ†ÌÉùÌïòÏã† ' + selection.getA1Notation();
  } else {
    protectedLastRow = 32;
    protectedLastCol = 8;
    rangeDescription = 'Í∏∞Î≥∏ Î≤îÏúÑÏù∏ A1:H32';
  }

  const maxRows = sheet.getMaxRows();
  const maxCols = sheet.getMaxColumns();

  if (maxRows > protectedLastRow) {
    sheet
      .getRange(protectedLastRow + 1, 1, maxRows - protectedLastRow, maxCols)
      .clear({ contentsOnly: true, formatOnly: true, commentsOnly: true, validationsOnly: true });
  }

  if (maxCols > protectedLastCol) {
    sheet
      .getRange(1, protectedLastCol + 1, protectedLastRow, maxCols - protectedLastCol)
      .clear({ contentsOnly: true, formatOnly: true, commentsOnly: true, validationsOnly: true });
  }

  ui.alert(
    'ÏÑ±Í≥µ',
    rangeDescription + ' Î≤îÏúÑÎ•º Ï†úÏô∏Ìïú Î™®Îì† Ïô∏Î∂Ä ÏÖÄÏùò ÏÑúÏãùÍ≥º Îç∞Ïù¥ÌÑ∞Î•º Ï†ïÎ¶¨ÌñàÏäµÎãàÎã§.',
    ui.ButtonSet.OK
  );
}

/* =========================
 * ÏùºÏ†ï Ï†ïÎ†¨ (Ïã†Í¥Ä/Î≥∏Í¥Ä)
 * ========================= */

function sortSingwanSchedule() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const userSelection = sheet.getActiveRange();
  if (!userSelection || userSelection.getNumRows() <= 1) return;

  const startRow = userSelection.getRow();
  const numRows = userSelection.getNumRows();
  const startCol = 3;
  const numCols = 5;
  const fullRangeToSort = sheet.getRange(startRow, startCol, numRows, numCols);

  const TIME_COL_INDEX = 0;
  const ROOM_COL_INDEX = 1;

  try {
    const roomPriority = {
      'ÎåÄÌöåÏùòÏã§': 1,
      'Ï§ëÌöåÏùòÏã§': 2,
      '1ÏÜåÌöåÏùòÏã§': 3,
      '2ÏÜåÌöåÏùòÏã§': 4,
      '3ÏÜåÌöåÏùòÏã§': 5,
      'Í≤ΩÏòÅÏ†ÑÎûµÏã§': 6
    };
    sortHelper_(fullRangeToSort, roomPriority, TIME_COL_INDEX, ROOM_COL_INDEX);
  } catch (e) {
    Logger.log('Ïã†Í¥Ä Ï†ïÎ†¨ Ïò§Î•ò: ' + e.message);
    ui.alert('Ïò§Î•ò', 'Ïã†Í¥Ä ÏùºÏ†ï Ï†ïÎ†¨ Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', ui.ButtonSet.OK);
  }
}

function sortBongwanSchedule() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const userSelection = sheet.getActiveRange();
  if (!userSelection || userSelection.getNumRows() <= 1) return;

  const startRow = userSelection.getRow();
  const numRows = userSelection.getNumRows();
  const startCol = 3;
  const numCols = 5;
  const fullRangeToSort = sheet.getRange(startRow, startCol, numRows, numCols);

  const TIME_COL_INDEX = 0;
  const ROOM_COL_INDEX = 1;

  try {
    const roomPriority = {
      'ÎåÄÍ∞ïÎãπ': 1,
      'Ï§ëÌöåÏùòÏã§': 2,
      'ÌôîÏÉÅÌöåÏùòÏã§': 3,
      'ÏÜåÌöåÏùòÏã§': 4,
      'Ïã†ÌÜ†Î∂àÏù¥': 5,
      'ÎëêÎ†àÏãùÎãπ': 6
    };
    sortHelper_(fullRangeToSort, roomPriority, TIME_COL_INDEX, ROOM_COL_INDEX);
  } catch (e) {
    Logger.log('Î≥∏Í¥Ä Ï†ïÎ†¨ Ïò§Î•ò: ' + e.message);
    ui.alert('Ïò§Î•ò', 'Î≥∏Í¥Ä ÏùºÏ†ï Ï†ïÎ†¨ Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', ui.ButtonSet.OK);
  }
}

function sortHelper_(rangeToSort, roomPriority, timeIndex, roomIndex) {
  const sheet = rangeToSort.getSheet();
  const startRow = rangeToSort.getRow();
  const startCol = rangeToSort.getColumn();
  const numRows = rangeToSort.getNumRows();

  const E_COL_INDEX_IN_RANGE = 2;
  const eColumnRichText = sheet
    .getRange(startRow, startCol + E_COL_INDEX_IN_RANGE, numRows, 1)
    .getRichTextValues();

  const fullFormats = {
    values: rangeToSort.getValues(),
    displayValues: rangeToSort.getDisplayValues(),
    numberFormats: rangeToSort.getNumberFormats(),
    backgrounds: rangeToSort.getBackgrounds(),
    horizontalAlignments: rangeToSort.getHorizontalAlignments(),
    wrapStrategies: rangeToSort.getWrapStrategies(),
    notes: rangeToSort.getNotes()
  };

  const data = [];
  for (let i = 0; i < numRows; i++) {
    data.push({
      timeKey: fullFormats.displayValues[i][timeIndex],
      roomKey: fullFormats.displayValues[i][roomIndex] || '',
      eColumnRichText: eColumnRichText[i][0],
      otherData: {
        values: fullFormats.values[i],
        numberFormats: fullFormats.numberFormats[i],
        backgrounds: fullFormats.backgrounds[i],
        horizontalAlignments: fullFormats.horizontalAlignments[i],
        wrapStrategies: fullFormats.wrapStrategies[i],
        notes: fullFormats.notes[i]
      }
    });
  }

  const toSort = data.filter(r => r.timeKey && r.timeKey.trim() !== '');
  const notToSort = data.filter(r => !r.timeKey || r.timeKey.trim() === '');

  toSort.sort((a, b) => {
    const pa = a.timeKey.split('~');
    const pb = b.timeKey.split('~');
    const sa = new Date('1970/01/01 ' + pa[0].trim());
    const sb = new Date('1970/01/01 ' + pb[0].trim());
    const ea = new Date('1970/01/01 ' + (pa[1] || pa[0]).trim());
    const eb = new Date('1970/01/01 ' + (pb[1] || pb[0]).trim());
    const aIs = !isNaN(sa.getTime());
    const bIs = !isNaN(sb.getTime());

    if (aIs && bIs) {
      const s = sa - sb;
      if (s !== 0) return s;
      const e = ea - eb;
      if (e !== 0) return e;
      const pao = roomPriority[a.roomKey.trim()] || 99;
      const pbo = roomPriority[b.roomKey.trim()] || 99;
      return pao - pbo;
    }
    return a.timeKey.localeCompare(b.timeKey);
  });

  const sorted = toSort.concat(notToSort);
  const newE = sorted.map(d => [d.eColumnRichText]);
  const newV = sorted.map(d => d.otherData.values);
  const newNF = sorted.map(d => d.otherData.numberFormats);
  const newBg = sorted.map(d => d.otherData.backgrounds);
  const newHA = sorted.map(d => d.otherData.horizontalAlignments);
  const newWS = sorted.map(d => d.otherData.wrapStrategies);
  const newNt = sorted.map(d => d.otherData.notes);

  rangeToSort
    .setValues(newV)
    .setNumberFormats(newNF)
    .setBackgrounds(newBg)
    .setHorizontalAlignments(newHA)
    .setVerticalAlignment('middle')
    .setWrapStrategies(newWS)
    .setNotes(newNt);

  sheet
    .getRange(startRow, startCol + E_COL_INDEX_IN_RANGE, numRows, 1)
    .setRichTextValues(newE);
}

/* =========================
 * ÌÇ§ÏõåÎìú ÏûêÎèô ÏÑúÏãù (Ï§ÑÎ≥Ñ Ìè∞Ìä∏ ÌÅ¨Í∏∞ Î≥¥Ï°¥)
 * ========================= */

function _computeLineBoundaries_(text) {
  const lines = String(text || '').split('\n');
  const bounds = [];
  let idx = 0;
  for (let i = 0; i < lines.length; i++) {
    const start = idx;
    const end = idx + lines[i].length;
    bounds.push({ start: start, end: end });
    idx = end + 1;
  }
  return bounds;
}

function _inferPerLineFontSizes_(rt) {
  if (!rt) return [];
  const text = rt.getText();
  const lines = _computeLineBoundaries_(text);
  if (!lines.length) return [];

  const runs = rt.getRuns() || [];
  const weights = lines.map(() => Object.create(null));

  runs.forEach(run => {
    const s = run.getStartIndex();
    const e = run.getEndIndex();
    const style = run.getTextStyle && run.getTextStyle();
    const sz = style && typeof style.getFontSize === 'function' ? style.getFontSize() : null;
    if (sz == null) return;

    for (let li = 0; li < lines.length; li++) {
      const L = lines[li];
      const overlap = Math.max(0, Math.min(e, L.end) - Math.max(s, L.start));
      if (overlap > 0) {
        weights[li][sz] = (weights[li][sz] || 0) + overlap;
      }
    }
  });

  return weights.map(w => {
    let bestSize = null;
    let bestW = -1;
    for (const k in w) {
      const size = Number(k);
      const ww = w[k];
      if (ww > bestW) {
        bestW = ww;
        bestSize = size;
      }
    }
    return bestSize;
  });
}

function formatTitleLinesBoldUnderline(e) {
  if (!e || !e.range || typeof e.value !== 'string') return;

  const cell = e.range;
  if (cell.getNumRows() > 1 || cell.getNumColumns() > 1) return;
  if (cell.getFormula()) return;

  const sheet = cell.getSheet();
  const ss = sheet.getParent();

  if (AUTO_FMT.ENABLED_SHEETS.indexOf(sheet.getName()) === -1) return;

  const excludeRng = ss.getRangeByName(AUTO_FMT.EXCLUDE_NAMED_RANGE);
  if (_isCellInRange_(excludeRng, cell)) return;

  const targetRng = ss.getRangeByName(AUTO_FMT.TARGET_NAMED_RANGE);
  if (targetRng) {
    if (!_isCellInRange_(targetRng, cell)) return;
  } else {
    if (cell.getColumn() !== AUTO_FMT.TARGET_COLUMN) return;
  }

  const anchorRow = _findAnchorRowByText_(sheet, AUTO_FMT.ANCHOR_TEXT);
  if (anchorRow && cell.getRow() >= anchorRow) return;

  const currentRT = cell.getRichTextValue();
  const originalText = currentRT ? currentRT.getText() : e.value.toString();

  const starKeywords = ['(ÌöåÏû•)'];
  const boldUnderlineKeywords = ['(Î∂ÄÌöåÏû•)'];
  const boldOnlyKeywords = [
    '(ÏÉÅÌò∏Í∏àÏúµÎåÄÌëú)',
    '(ÏùÄÌñâÏû•)',
    '(Ï∂ïÏÇ∞Í≤ΩÏ†úÎåÄÌëú)',
    '(ÎÜçÏóÖÍ≤ΩÏ†úÎåÄÌëú)',
    '(Í∞êÏÇ¨ÏúÑÏõêÏû•)',
    '(Í∏àÏúµÏßÄÏ£ºÌöåÏû•)',
    '(Ï°∞Ìï©Í∞êÏÇ¨ÏúÑÏõêÏû•)',
    '(Í≤ΩÏ†úÏßÄÏ£ºÎåÄÌëú)'
  ];
  const boldWordKeywords = ['Íµ≠ÎØºÏùòÎ°Ä', 'ÎÖπÏùå', 'ÎÖπÌôî'];

  let lines = originalText.split('\n');

  lines = lines.map(line => {
    const hasStarTarget = starKeywords.some(kw => line.indexOf(kw) !== -1);
    if (hasStarTarget && line.indexOf('‚òÖ') !== 0) {
      return '‚òÖ' + line;
    }
    return line;
  });

  const newText = lines.join('\n');

  let builder;
  if (currentRT && newText === originalText) {
    builder = currentRT.copy();
  } else {
    builder = SpreadsheetApp.newRichTextValue().setText(newText);

    const oldLineSizes = currentRT ? _inferPerLineFontSizes_(currentRT) : [];
    const newLineBounds = _computeLineBoundaries_(newText);

    for (let i = 0; i < newLineBounds.length; i++) {
      const size = oldLineSizes[i];
      if (size != null) {
        const L = newLineBounds[i];
        if (L.end > L.start) {
          builder.setTextStyle(
            L.start,
            L.end,
            SpreadsheetApp.newTextStyle().setFontSize(size).build()
          );
        }
      }
    }
  }

  const boldStyle = SpreadsheetApp.newTextStyle().setBold(true).build();
  const boldUnderlineStyle = SpreadsheetApp.newTextStyle().setBold(true).setUnderline(true).build();

  let cursor = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineLen = line.length;

    const applyRange = (style, from, to) => {
      const start = Math.max(0, from);
      const end = Math.min(lineLen, to);
      if (end > start) builder.setTextStyle(cursor + start, cursor + end, style);
    };

    if (line.indexOf('‚òÖ') === 0) {
      starKeywords.forEach(kw => {
        const idx = line.indexOf(kw);
        if (idx !== -1) {
          applyRange(boldUnderlineStyle, 0, idx + kw.length);
        }
      });
    }

    boldUnderlineKeywords.forEach(kw => {
      const idx = line.indexOf(kw);
      if (idx !== -1) {
        applyRange(boldUnderlineStyle, 0, idx + kw.length);
      }
    });

    boldOnlyKeywords.forEach(kw => {
      const idx = line.indexOf(kw);
      if (idx !== -1) {
        applyRange(boldStyle, 0, idx + kw.length);
      }
    });

    boldWordKeywords.forEach(word => {
      let idx = line.indexOf(word);
      while (idx !== -1) {
        applyRange(boldStyle, idx, idx + word.length);
        idx = line.indexOf(word, idx + word.length);
      }
    });

    cursor += lineLen + 1;
  }

  cell.setRichTextValue(builder.build());
}

/* =========================
 * Ïù¥ÎØ∏ÏßÄ Î¶¨ÏÇ¨Ïù¥Ï¶à Ïú†Ìã∏
 * ========================= */

function getResizedBlobFromDrive_(fileId, targetW, targetH) {
  try {
    const w = Math.max(10, Math.floor(targetW));
    const h = Math.max(10, Math.floor(targetH));
    const url =
      'https://drive.google.com/thumbnail?authuser=0&sz=w' +
      w +
      '-h' +
      h +
      '&id=' +
      encodeURIComponent(fileId);
    const token = ScriptApp.getOAuthToken();
    const res = UrlFetchApp.fetch(url, {
      headers: { Authorization: 'Bearer ' + token },
      muteHttpExceptions: true,
      followRedirects: true
    });
    const code = res.getResponseCode();
    if (code !== 200) throw new Error('thumb HTTP ' + code);
    const blob = res.getBlob();
    const ct = blob.getContentType() || '';
    if (/text\/html/i.test(ct)) throw new Error('thumb HTML');
    return blob;
  } catch (e) {
    return DriveApp.getFileById(fileId).getBlob();
  }
}

function fitAndShrinkDriveImage_(fileId, targetW, targetH, maxBytes, maxPixels) {
  maxBytes = maxBytes || 2 * 1024 * 1024;
  maxPixels = maxPixels || 1000000;

  let blob = getResizedBlobFromDrive_(fileId, targetW, targetH);
  let factor = 1.0;

  for (let i = 0; i < 8; i++) {
    const bytes = blob.getBytes().length;
    const estPixels = Math.round(targetW * factor * (targetH * factor));
    if (bytes <= maxBytes && estPixels <= maxPixels) break;

    factor *= 0.85;
    const bw = Math.max(10, Math.floor(targetW * factor));
    const bh = Math.max(10, Math.floor(targetH * factor));
    blob = getResizedBlobFromDrive_(fileId, bw, bh);
  }

  return blob;
}

/* =========================
 * ÏûÑÏãú ÌååÏùº ÏÇ≠Ï†ú Ïú†Ìã∏
 * ========================= */

function _hardDeleteFileOrTrashFallback_(fileId) {
  try {
    if (typeof Drive !== 'undefined' && Drive.Files && typeof Drive.Files.remove === 'function') {
      Drive.Files.remove(fileId);
      return true;
    }
  } catch (e) {
    Logger.log('Drive.Files.remove Ïã§Ìå®: ' + (e && e.message ? e.message : e));
  }
  try {
    DriveApp.getFileById(fileId).setTrashed(true);
    return false;
  } catch (e2) {
    Logger.log('DriveApp setTrashed Ïã§Ìå®: ' + (e2 && e2.message ? e2.message : e2));
    return false;
  }
}

/* =========================
 * PDF Ï†ÄÏû•(Ïõî~4p ÏßÅÏ†Ñ)
 * ========================= */

function exportRangeToPdfBetweenMarkers() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();
  const excludeSet = getExcludedSheetNames_(ss);

  const namesToExport = [];
  let inRange = false;

  for (let i = 0; i < sheets.length; i++) {
    const s = sheets[i];
    const nm = s.getName();
    if (isEndMarker_(nm)) break;

    if (!inRange) {
      if (matchStart_(nm)) {
        inRange = true;
        if (isWeekdaySheet_(nm) && !shouldSkipSheet_(s, excludeSet)) namesToExport.push(nm);
      }
      continue;
    }

    if (isWeekdaySheet_(nm) && !shouldSkipSheet_(s, excludeSet)) namesToExport.push(nm);
  }

  if (namesToExport.length === 0) {
    ui.alert('ÏïåÎ¶º', 'Ï†ÄÏû•Ìï† ÏãúÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§. Î≤îÏúÑ/ÏòàÏô∏ ÏÑ§Ï†ïÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.', ui.ButtonSet.OK);
    return;
  }

  const weekLabel = getWeekRangeLabelFromSheets_(ss);

  const temp = SpreadsheetApp.create('TEMP_PDF_' + Date.now());
  const tempId = temp.getId();
  const placeholder = temp.getActiveSheet().setName('_PLACEHOLDER_');

  const copied = [];
  namesToExport.forEach(nm => {
    const s = ss.getSheetByName(nm);
    if (!s) return;
    const c = s.copyTo(temp);
    try {
      c.setName(nm);
    } catch (_) {
      const ts = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'HHmmss');
      c.setName(nm + '_' + ts);
    }
    materializeDriveImagesWithCrossSheet_(c, ss);
    copied.push(c.getName());
  });

  if (temp.getSheets().length > 1) temp.deleteSheet(placeholder);

  const afterSheets = temp.getSheets();
  for (let i = 0; i < afterSheets.length; i++) {
    const s = afterSheets[i];
    const nm = s.getName();
    if (!isWeekdaySheet_(nm) || shouldSkipSheetByNameString_(nm)) {
      try {
        temp.deleteSheet(s);
      } catch (_) {}
    }
  }

  SpreadsheetApp.flush();
  sleepMs_(PDF_EXPORT.IMAGE_RENDER_WAIT_MS);

  const params = {
    format: 'pdf',
    size: 'A4',
    portrait: 'true',
    fitw: 'true',
    top_margin: '0.5',
    bottom_margin: '0.5',
    left_margin: '0.5',
    right_margin: '0.5',
    sheetnames: 'true',
    printtitle: 'false',
    pagenum: 'CENTER',
    gridlines: 'false',
    fzr: 'false',
    printnotes: 'false'
  };
  const query = Object.keys(params)
    .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))
    .join('&');
  const url = 'https://docs.google.com/spreadsheets/d/' + tempId + '/export?' + query;

  let blob;
  try {
    blob = fetchPdfOrThrow_(url);
  } catch (e1) {
    Logger.log('[Retry] ' + e1.message);
    SpreadsheetApp.flush();
    sleepMs_(1200);
    blob = fetchPdfOrThrow_(url);
  }

  const fname = (PDF_EXPORT.FILE_PREFIX || '') + '(' + weekLabel + ').pdf';
  blob.setName(fname);

  const folder = _resolveTargetFolderOrFallback_(ss);
  folder.createFile(blob);

  _hardDeleteFileOrTrashFallback_(tempId);

  ui.alert(
    'ÏôÑÎ£å',
    'PDF Ï†ÄÏû• ÏôÑÎ£å\n\nÌè¨Ìï® ÏãúÌä∏: ' +
      copied.join(', ') +
      '\nÌååÏùºÎ™Ö: ' +
      fname +
      '\nÏ†ÄÏû• ÏúÑÏπò: ' +
      folder.getName(),
    ui.ButtonSet.OK
  );
}

/* =========================
 * ÌååÏùºÎ™Ö ÏÉùÏÑ± Ïú†Ìã∏(E2 ‚Üí MM.DD~MM.DD)
 * ========================= */

function getWeekRangeLabelFromSheets_(ss) {
  function pad2(n) {
    n = Number(n);
    return (n < 10 ? '0' : '') + n;
  }

  function parseToMonthDay(text) {
    if (text == null) return null;
    const s = String(text).trim();
    if (!s) return null;

    let m = s.match(/(\d{4})[.\-\/](\d{1,2})[.\-\/](\d{1,2})/);
    if (m) return { m: pad2(m[2]), d: pad2(m[3]) };

    m = s.match(/(\d{1,2})[.\-\/](\d{1,2})/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    m = s.match(/(\d{1,2})\s*Ïõî\s*(\d{1,2})\s*Ïùº/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    m = s.match(/(\d{1,2})\s*[\.\-\/]\s*(\d{1,2})/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    m = s.match(/(\d{1,2})(\d{2})/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    const num = Number(s);
    if (!isNaN(num)) {
      const d = new Date(s);
      if (!isNaN(d.getTime())) return { m: pad2(d.getMonth() + 1), d: pad2(d.getDate()) };
    }
    return null;
  }

  function getE2MD(sheetName) {
    const sh = ss.getSheetByName(sheetName);
    if (!sh) return null;
    const v = sh.getRange('E2').getDisplayValue();
    return parseToMonthDay(v);
  }

  const fromMD = getE2MD('Ïõî');
  const toMD = getE2MD('Í∏à');
  const fromLabel = fromMD ? fromMD.m + '.' + fromMD.d : 'MM.DD';
  const toLabel = toMD ? toMD.m + '.' + toMD.d : 'MM.DD';
  return fromLabel + '~' + toLabel;
}

/* =========================
 * ÌòÑÏû¨ ÏãúÌä∏: IMAGE ‚Üí Ïò§Î≤ÑÎ†àÏù¥ ÏπòÌôò
 * ========================= */

function replaceImageFunctionsOnActiveSheet_Overlay() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSheet();
  const ss = sheet.getParent();

  const lr = sheet.getLastRow();
  const lc = sheet.getLastColumn();
  if (lr === 0 || lc === 0) {
    ui.alert('Ïò§Î≤ÑÎ†àÏù¥ ÏπòÌôò', 'ÏãúÌä∏Í∞Ä ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§.', ui.ButtonSet.OK);
    return;
  }

  const rg = sheet.getRange(1, 1, lr, lc);
  const formulas = rg.getFormulas();

  const RE_IMAGE = /(^|=|\W)IMAGE\s*\(/i;
  const RE_ID_PARAM = /[?&]id=([a-zA-Z0-9_-]{20,})/i;
  const RE_PATH_ID = /\/d\/([a-zA-Z0-9_-]{20,})(?:\/|$)/i;
  const RE_ANY_URL = /https?:\/\/[^\s")]+/gi;
  const RE_A1_ANY = /(?:'([^']+)'\s*!|([A-Za-z0-9_]+)\s*!|\b)(\$?[A-Z]+\$?\d+)\b/g;

  function pickIdFromString(s) {
    if (!s) return { id: null, url: null };
    const str = String(s);

    let m = str.match(RE_ID_PARAM);
    if (m && m[1]) return { id: m[1], url: null };

    m = str.match(RE_PATH_ID);
    if (m && m[1]) return { id: m[1], url: null };

    const urls = str.match(RE_ANY_URL) || [];
    for (let i = 0; i < urls.length; i++) {
      const u = urls[i];
      let k = u.match(RE_ID_PARAM);
      if (k && k[1]) return { id: k[1], url: u };
      k = u.match(RE_PATH_ID);
      if (k && k[1]) return { id: k[1], url: u };
    }

    const cleaned = str.replace(/["'+&=\s]/g, '');
    if (/^[a-zA-Z0-9_-]{20,}$/.test(cleaned)) return { id: cleaned, url: null };

    return { id: null, url: null };
  }

  function resolveA1RefsToValues(formula) {
    if (!formula) return '';
    return String(formula).replace(RE_A1_ANY, (m, qName1, name2, a1) => {
      try {
        if (qName1 || name2) {
          const name = qName1 ? qName1 : name2;
          const src = ss.getSheetByName(name);
          if (!src) return '';
          return src.getRange(a1).getDisplayValue();
        } else {
          return sheet.getRange(a1).getDisplayValue();
        }
      } catch (_) {
        return '';
      }
    });
  }

  function collectA1Refs(formula) {
    const refs = [];
    if (!formula) return refs;
    String(formula).replace(RE_A1_ANY, (m, qName1, name2, a1) => {
      if (qName1 || name2) refs.push({ sheetName: qName1 ? qName1 : name2, a1: a1 });
      else refs.push({ sheetName: null, a1: a1 });
      return m;
    });
    return refs;
  }

  function insertOverlay(a1, fileId, padPx) {
    const cell = sheet.getRange(a1);
    const box = cell.isPartOfMerge() ? cell.getMergedRanges()[0] : cell;
    const r0 = box.getRow();
    const c0 = box.getColumn();

    let w = 0;
    let h = 0;
    for (let c = c0; c < c0 + box.getNumColumns(); c++) w += sheet.getColumnWidth(c);
    for (let r = r0; r < r0 + box.getNumRows(); r++) h += sheet.getRowHeight(r);

    w = Math.max(10, w - (padPx || 0));
    h = Math.max(10, h - (padPx || 0));

    const blob = fitAndShrinkDriveImage_(fileId, w, h, 2 * 1024 * 1024, 1000000);
    const over = sheet.insertImage(blob, c0, r0);
    over.setWidth(Math.round(w));
    over.setHeight(Math.round(h));
    try {
      over.setAnchorCell(r0, c0).setAnchorCellXOffset(0).setAnchorCellYOffset(0);
    } catch (_) {}
    try {
      box.setValue('');
    } catch (_) {}
  }

  try {
    sheet.getImages().forEach(img => {
      try {
        img.remove();
      } catch (_) {}
    });
  } catch (_) {}

  let nFound = 0;
  let nResolved = 0;
  let nInserted = 0;
  const debugLines = [];
  const fails = [];

  for (let r = 0; r < lr; r++) {
    for (let c = 0; c < lc; c++) {
      const f = formulas[r][c];
      if (!f) continue;
      if (!RE_IMAGE.test(f)) continue;

      const a1 = sheet.getRange(r + 1, c + 1).getA1Notation();
      nFound++;

      const resolved = resolveA1RefsToValues(f);
      let pick = pickIdFromString(resolved);

      const scannedRefs = [];
      if (!pick.id) {
        const refs = collectA1Refs(f);
        for (let i = 0; i < refs.length; i++) {
          const ref = refs[i];
          try {
            const rng = ref.sheetName
              ? ss.getSheetByName(ref.sheetName).getRange(ref.a1)
              : sheet.getRange(ref.a1);
            const val = rng.getDisplayValue();
            const p2 = pickIdFromString(val);
            scannedRefs.push((ref.sheetName ? "'" + ref.sheetName + "'!" : '') + ref.a1 + '=' + val);
            if (p2.id) {
              pick = p2;
              break;
            }
          } catch (_) {}
        }
      }

      if (pick.id) {
        nResolved++;
        try {
          insertOverlay(a1, pick.id, 2);
          sheet.getRange(a1).clearContent();
          nInserted++;
          debugLines.push('[OK] ' + a1 + '  id=' + pick.id);
        } catch (e) {
          fails.push(a1 + ' - ÏÇΩÏûÖÏã§Ìå®: ' + e);
          debugLines.push('[ERR-INSERT] ' + a1 + '  id=' + pick.id + '  err=' + e);
        }
      } else {
        fails.push(a1 + ' - ID ÎØ∏Í≤ÄÏ∂ú');
        debugLines.push(
          '[MISS] ' +
            a1 +
            '\n  formula: ' +
            f +
            '\n  resolved: ' +
            resolved +
            '\n  refScan: ' +
            scannedRefs.join(' | ')
        );
      }
    }
  }

  SpreadsheetApp.flush();
  Utilities.sleep(800);

  const headDetail = debugLines.slice(0, 20).join('\n');
  const summary = [
    'ÌÉêÏßÄÎêú IMAGE ÏàòÏãù: ' + nFound + 'Í∞ú',
    'ID Ìï¥ÏÑù ÏÑ±Í≥µ: ' + nResolved + 'Í∞ú',
    'Ïò§Î≤ÑÎ†àÏù¥ ÏÇΩÏûÖ ÏÑ±Í≥µ: ' + nInserted + 'Í∞ú',
    fails.length
      ? '\nÏã§Ìå® Î™©Î°ù(ÏöîÏïΩ):\n' +
        fails.slice(0, 10).join('\n') +
        (fails.length > 10 ? '\n‚Ä¶Ïô∏ ' + (fails.length - 10) + 'Í±¥' : '')
      : '',
    '\nÏÉÅÏÑ∏(ÏùºÎ∂Ä):\n' + headDetail
  ].join('\n');

  ui.alert('Ïò§Î≤ÑÎ†àÏù¥ ÏπòÌôò Í≤∞Í≥º', summary, ui.ButtonSet.OK);
  Logger.log('==== Overlay Replace Detail ====\n' + debugLines.join('\n'));
}

/* =========================
 * Î≥µÏÇ¨Î≥∏ ÏãúÌä∏: IMAGE ‚Üí Ïò§Î≤ÑÎ†àÏù¥ Î≥ÄÌôò
 * ========================= */

function materializeDriveImagesWithCrossSheet_(sheetCopy, originalSS) {
  const lr = sheetCopy.getLastRow();
  const lc = sheetCopy.getLastColumn();
  if (lr === 0 || lc === 0) return;

  const rg = sheetCopy.getRange(1, 1, lr, lc);
  const formulas = rg.getFormulas();
  const displays = rg.getDisplayValues();

  const anyImageCall = /(^|=|\W)IMAGE\s*\(/i;
  const idParamRegex = /id=([a-zA-Z0-9_-]{20,})/i;
  const filePathRegex = /\/d\/([a-zA-Z0-9_-]{20,})(?:\/|$)/i;

  function resolveCrossSheetRefs_(formula) {
    if (!formula) return '';
    const refRegex = /(?:'([^']+)'|([A-Za-z0-9_]+))?!([A-Z]+[0-9]+)|\b([A-Z]+[0-9]+)\b/g;
    return String(formula).replace(refRegex, (m, q1, s2, a1, a1Local) => {
      try {
        if (a1Local) {
          const v = sheetCopy.getRange(a1Local).getDisplayValue();
          return String(v || '');
        } else if (a1) {
          const sheetName = q1 ? q1 : s2;
          const srcSheet = originalSS.getSheetByName(sheetName);
          if (!srcSheet) return '';
          const v2 = srcSheet.getRange(a1).getDisplayValue();
          return String(v2 || '');
        }
        return '';
      } catch (_) {
        return '';
      }
    });
  }

  function detectDriveId_(textOrFormula) {
    if (!textOrFormula) return null;
    let s = String(textOrFormula);

    let m = s.match(idParamRegex);
    if (m && m[1]) return m[1];

    m = s.match(filePathRegex);
    if (m && m[1]) return m[1];

    s = s.replace(/["'+&\s]/g, '');
    if (/^[a-zA-Z0-9_-]{20,}$/.test(s)) return s;

    return null;
  }

  function measureMergedPixelBox_(r, c) {
    const cell = sheetCopy.getRange(r + 1, c + 1);
    const mr = cell.isPartOfMerge() ? cell.getMergedRanges()[0] : cell;
    const rows = mr.getNumRows();
    const cols = mr.getNumColumns();

    let totalW = 0;
    let totalH = 0;
    for (let cc = mr.getColumn(); cc < mr.getColumn() + cols; cc++) {
      totalW += sheetCopy.getColumnWidth(cc);
    }
    for (let rr = mr.getRow(); rr < mr.getRow() + rows; rr++) {
      totalH += sheetCopy.getRowHeight(rr);
    }

    return {
      box: mr,
      pxW: Math.max(10, totalW - 2),
      pxH: Math.max(10, totalH - 2)
    };
  }

  let hasAnyImageFormula = false;
  for (let r0 = 0; r0 < formulas.length && !hasAnyImageFormula; r0++) {
    for (let c0 = 0; c0 < formulas[r0].length; c0++) {
      if (anyImageCall.test(formulas[r0][c0] || '')) {
        hasAnyImageFormula = true;
        break;
      }
    }
  }

  if (hasAnyImageFormula) {
    try {
      sheetCopy.getImages().forEach(img => {
        try {
          img.remove();
        } catch (_) {}
      });
    } catch (_) {}
  }

  if (hasAnyImageFormula) {
    for (let r = 0; r < formulas.length; r++) {
      for (let c = 0; c < formulas[r].length; c++) {
        let fileId = null;
        const f = formulas[r][c] || '';

        if (anyImageCall.test(f)) {
          const resolved = resolveCrossSheetRefs_(f);
          fileId = detectDriveId_(resolved);
        }
        if (!fileId) fileId = detectDriveId_(displays[r][c] || '');
        if (!fileId) continue;

        try {
          const m = measureMergedPixelBox_(r, c);
          let w = m.pxW;
          let h = m.pxH;
          const px = w * h;
          if (px > 1000000) {
            const s = Math.sqrt(1000000 / px);
            w = Math.max(10, Math.floor(w * s));
            h = Math.max(10, Math.floor(h * s));
          }
          const blob = fitAndShrinkDriveImage_(fileId, w, h, 2 * 1024 * 1024, 1000000);
          const over = sheetCopy.insertImage(blob, m.box.getColumn(), m.box.getRow());
          over.setWidth(Math.round(w));
          over.setHeight(Math.round(h));
          try {
            over
              .setAnchorCell(m.box.getRow(), m.box.getColumn())
              .setAnchorCellXOffset(0)
              .setAnchorCellYOffset(0);
          } catch (_) {}
          try {
            m.box.setValue('');
          } catch (_) {}
        } catch (_) {}
      }
    }
    SpreadsheetApp.flush();
    Utilities.sleep(1800);
  } else {
    SpreadsheetApp.flush();
    Utilities.sleep(1200);
  }
}

/* =========================
 * ÏÇ¨ÏßÑ ÏóÖÎ°úÎìú ÏûêÎèôÌôî
 * ========================= */

function automateFullImageProcess() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  try {
    const sheet = ss.getActiveSheet();
    const sname = sheet.getName().toLowerCase();

    if (sname === '4p' || sname === '6p') {
      const src = sheet.getRange('A1');
      const raw = String(src.getValue() || '').trim();
      if (raw) {
        const ids = getDriveIdsFromSource_(src);
        src.clearContent();
        if (ids.length === 0) {
          ui.alert('ÏïåÎ¶º', 'A1ÏóêÏÑú Ïú†Ìö®Ìïú Drive ÎßÅÌÅ¨/IDÎ•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.', ui.ButtonSet.OK);
          return;
        }
        if (applyIdsToTargetSheet_(sheet, ids)) {
          ui.alert('ÏÑ±Í≥µ', "'" + sheet.getName() + "' ÏãúÌä∏ ÏÇ¨ÏßÑ Ïó∞Îèô ÏôÑÎ£å!", ui.ButtonSet.OK);
        }
        return;
      }
    }

    const inputSheet = ss.getSheetByName('ÏûÖÎ†•');
    if (inputSheet) {
      const box = inputSheet.getRange('B2');
      const raw = String(box.getValue() || '').trim();
      if (raw) {
        const resp = ui.prompt(
          'ÏÇ¨ÏßÑ ID Ïó∞Îèô',
          'ÎßÅÌÅ¨Î•º Ï†ÅÏö©Ìï† "ÎåÄÏÉÅ ÏãúÌä∏ Ïù¥Î¶Ñ"ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.',
          ui.ButtonSet.OK_CANCEL
        );
        if (resp.getSelectedButton() !== ui.Button.OK) return;

        const targetName = String(resp.getResponseText() || '').trim();
        if (!targetName) {
          ui.alert('Ïò§Î•ò', 'ÏãúÌä∏ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.', ui.ButtonSet.OK);
          return;
        }

        const target = ss.getSheetByName(targetName);
        if (!target) {
          ui.alert('Ïò§Î•ò', '"' + targetName + '" ÏãúÌä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.', ui.ButtonSet.OK);
          return;
        }

        const ids = getDriveIdsFromSource_(box);
        box.clearContent();
        if (ids.length === 0) {
          ui.alert('ÏïåÎ¶º', "'ÏûÖÎ†•'!B2ÏóêÏÑú Ïú†Ìö®Ìïú ÎßÅÌÅ¨/IDÍ∞Ä ÏóÜÏäµÎãàÎã§.", ui.ButtonSet.OK);
          return;
        }
        if (applyIdsToTargetSheet_(target, ids)) {
          ui.alert('ÏÑ±Í≥µ', "'" + target.getName() + "' ÏãúÌä∏ ÏÇ¨ÏßÑ Ïó∞Îèô ÏôÑÎ£å!", ui.ButtonSet.OK);
        }
        return;
      }
    }

    ui.alert(
      'ÏïåÎ¶º',
      "Ï≤òÎ¶¨Ìï† ÎßÅÌÅ¨Í∞Ä ÏóÜÏäµÎãàÎã§.\n'4p'/'6p'!A1 ÎòêÎäî 'ÏûÖÎ†•'!B2Ïóê ÎßÅÌÅ¨/IDÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.",
      ui.ButtonSet.OK
    );
  } catch (e) {
    Logger.log('automateFullImageProcess Ïò§Î•ò: ' + (e && e.message ? e.message : e));
    SpreadsheetApp.getUi().alert('Ïò§Î•ò', 'ÏûêÎèôÌôî Í≥ºÏ†ï Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + e.message, ui.ButtonSet.OK);
  }
}

function getDriveIdsFromSource_(range) {
  const text = String(range.getValue() || '');
  if (!text.trim()) return [];
  const tokens = text
    .split(/[\s,;„ÄÄ\t\n]+/)
    .map(s => s.trim())
    .filter(v => !!v);
  return tokens.map(extractValidDriveId_).filter(v => !!v);
}

function extractValidDriveId_(str) {
  if (typeof str !== 'string' || !str.trim()) return null;
  const s = str.trim();

  let m = s.match(/\/d\/([a-zA-Z0-9_-]{25,})/);
  if (m) return m[1];

  m = s.match(/[?&]id=([a-zA-Z0-9_-]{25,})/);
  if (m) return m[1];

  m = s.match(/^[a-zA-Z0-9_-]{25,40}$/);
  if (m) return s;

  return null;
}

function applyIdsToTargetSheet_(targetSheet, newIds) {
  const ui = SpreadsheetApp.getUi();
  const name = targetSheet.getName().toLowerCase();

  try {
    if (name === '4p' || name === '6p') {
      const map = {
        '4p': [
          { imgCell: 'A5', idCell: 'A7' },
          { imgCell: 'F5', idCell: 'F7' },
          { imgCell: 'A8', idCell: 'A10' },
          { imgCell: 'F8', idCell: 'F10' }
        ],
        '6p': [
          { imgCell: 'A4', idCell: 'A6' },
          { imgCell: 'F4', idCell: 'F6' },
          { imgCell: 'A7', idCell: 'A9' },
          { imgCell: 'F7', idCell: 'F9' },
          { imgCell: 'A10', idCell: 'A12' },
          { imgCell: 'F10', idCell: 'F12' }
        ]
      };

      const pairs = map[name];
      const idVals = pairs.map(p =>
        (targetSheet.getRange(p.idCell).getValue() || '').toString().trim()
      );
      const numNew = newIds.length;
      const numEmpty = idVals.filter(v => v === '').length;
      let start = 0;

      if (numEmpty > 0) {
        if (numNew <= numEmpty) {
          start = idVals.findIndex(v => v === '');
        } else {
          pairs.forEach(p => {
            targetSheet.getRange(p.idCell).clearContent();
            targetSheet.getRange(p.imgCell).clearContent();
          });
          start = 0;
        }
      } else {
        const n = Math.min(numNew, pairs.length);
        for (let i = 0; i < n; i++) {
          const p = pairs[i];
          targetSheet.getRange(p.idCell).clearContent();
          targetSheet.getRange(p.imgCell).clearContent();
        }
        start = 0;
      }

      newIds.forEach((id, i) => {
        const idx = start + i;
        if (idx < pairs.length) {
          const p = pairs[idx];
          targetSheet.getRange(p.idCell).setValue(id);
          targetSheet
            .getRange(p.imgCell)
            .setFormula('=IMAGE("https://drive.google.com/uc?export=download&id=" & ' + p.idCell + ', 2)');
        }
      });
      return true;
    }

    const lr = targetSheet.getLastRow();
    const lc = targetSheet.getLastColumn();
    if (lr === 0 || lc === 0) {
      ui.alert('ÏïåÎ¶º', "'" + targetSheet.getName() + "' ÏãúÌä∏Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.", ui.ButtonSet.OK);
      return false;
    }

    const re = /IMAGE\("https?:\/\/drive\.google\.com\/uc\?export=download&id=" *& *([A-Z]+\d+)\)/i;
    const formulas = targetSheet.getRange(1, 1, lr, lc).getFormulas();
    const refCells = [];

    for (let r = 0; r < formulas.length; r++) {
      for (let c = 0; c < formulas[r].length; c++) {
        const f = formulas[r][c] || '';
        const m = f.match(re);
        if (m && m[1]) refCells.push(m[1]);
      }
    }

    const unique = Array.from(new Set(refCells)).sort((a, b) => {
      const ra = parseInt(a.match(/\d+/)[0], 10);
      const rb = parseInt(b.match(/\d+/)[0], 10);
      return ra !== rb ? ra - rb : a.localeCompare(b);
    });

    if (unique.length === 0) {
      ui.alert(
        'Ïò§Î•ò',
        "'" + targetSheet.getName() + "' ÏãúÌä∏ÏóêÏÑú IMAGE(\"...id=\" & A1) ÏàòÏãùÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.",
        ui.ButtonSet.OK
      );
      return false;
    }

    newIds.forEach((id, i) => {
      if (i < unique.length) targetSheet.getRange(unique[i]).setValue(id);
    });
    return true;
  } catch (e) {
    Logger.log(
      'applyIdsToTargetSheet_ Ïò§Î•ò(' +
        targetSheet.getName() +
        '): ' +
        (e && e.message ? e.message : e)
    );
    ui.alert(
      'Ïò§Î•ò',
      "'" + targetSheet.getName() + "' ÏãúÌä∏Ïóê ID Ï†ÅÏö© Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      ui.ButtonSet.OK
    );
    return false;
  }
}

/* =========================
 * ÏûêÎèô ÌÖåÎëêÎ¶¨ (Ìñâ ÏÇΩÏûÖ Ìä∏Î¶¨Í±∞Ïö©)
 * ========================= */

function AutoBorderRows_setupTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  if (!triggers.some(t => t.getHandlerFunction() === 'AutoBorderRows_onChange')) {
    ScriptApp.newTrigger('AutoBorderRows_onChange')
      .forSpreadsheet(SpreadsheetApp.getActive())
      .onChange()
      .create();
    try {
      SpreadsheetApp.getUi().alert('ÏûêÎèô ÌÖåÎëêÎ¶¨ Ìä∏Î¶¨Í±∞Í∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.');
    } catch (_) {}
  } else {
    try {
      SpreadsheetApp.getUi().alert('Ïù¥ÎØ∏ ÏûêÎèô ÌÖåÎëêÎ¶¨ Ìä∏Î¶¨Í±∞Í∞Ä Ï°¥Ïû¨Ìï©ÎãàÎã§.');
    } catch (_) {}
  }
}

function AutoBorderRows_removeTrigger() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'AutoBorderRows_onChange') {
      ScriptApp.deleteTrigger(t);
    }
  });
}

function isRowAnyBorder_(sheet, rowIndex) {
  if (rowIndex < 1 || rowIndex > sheet.getMaxRows()) return false;
  const range = sheet.getRange(rowIndex, 1, 1, sheet.getMaxColumns());
  const grid = fetchExistingBordersGrid_(sheet, range).grid;
  return grid[0].some(cellBorders => cellBorders && Object.keys(cellBorders).length > 0);
}

function AutoBorderRows_onChange(e) {
  if (!e || (e.changeType !== 'INSERT_ROW' && e.changeType !== 'INSERT_RANGE')) return;

  const ss = e.source;
  const sheet = ss.getActiveSheet();
  if (!sheet) return;

  Utilities.sleep(150);
  const ar = sheet.getActiveRange();
  if (!ar) return;

  const anchorRow = _findAnchorRowByText_(sheet, AUTO_FMT.ANCHOR_TEXT);
  if (anchorRow) {
    const firstInsertedRow = ar.getRow();
    const lastInsertedRow = ar.getLastRow();
    if (firstInsertedRow >= anchorRow || lastInsertedRow >= anchorRow) return;
  }

  const band = AutoBorderRows_resolveBandRange_(ss, sheet);
  if (!band) return;

  const firstInsertedRow = ar.getRow();
  const lastInsertedRow = ar.getLastRow();
  const aboveRowIndex = firstInsertedRow - 1;
  const belowRowIndex = lastInsertedRow + 1;

  if (aboveRowIndex < 1 || belowRowIndex > sheet.getMaxRows()) return;

  const aboveHas = isRowAnyBorder_(sheet, aboveRowIndex);
  const belowHas = isRowAnyBorder_(sheet, belowRowIndex);
  if (!(aboveHas && belowHas)) return;

  const pattern = MasterBorders_fetchPatternGrid_(ss);
  if (!pattern) return;

  const block = sheet.getRange(firstInsertedRow, band.getColumn(), ar.getNumRows(), band.getNumColumns());
  AutoBorderRows_paintRange_strongEdges_(sheet, block, band, pattern, aboveRowIndex, belowRowIndex);
}

function AutoBorderRows_resolveBandRange_(ss, sheet) {
  const name1 = 'ÏûêÎèôÌÖåÎëêÎ¶¨_Ïó¥Î≤îÏúÑ_' + sheet.getName();
  let r = ss.getRangeByName(name1);
  if (r && r.getSheet().getSheetId() === sheet.getSheetId()) return r;

  const name2 = 'ÏûêÎèôÌÖåÎëêÎ¶¨_Ïó¥Î≤îÏúÑ';
  r = ss.getRangeByName(name2);
  if (r && r.getSheet().getSheetId() === sheet.getSheetId()) return r;

  return null;
}

function AutoBorderRows_paintRange_strongEdges_(
  sheet,
  blockRange,
  band,
  pattern,
  aboveRowIndex,
  belowRowIndex
) {
  const ss = sheet.getParent();
  const sheetId = sheet.getSheetId();

  const numRows = blockRange.getNumRows();
  const numCols = band.getNumColumns();
  const startRow = blockRange.getRow();
  const startCol = band.getColumn();

  const rangeAbove = sheet.getRange(aboveRowIndex, startCol, 1, numCols);
  const rangeBelow = sheet.getRange(belowRowIndex, startCol, 1, numCols);

  const aboveGrid = fetchExistingBordersGrid_(sheet, rangeAbove).grid;
  const belowGrid = fetchExistingBordersGrid_(sheet, rangeBelow).grid;
  const existing = fetchExistingBordersGrid_(sheet, blockRange);

  const requests = [];

  for (let r = 0; r < numRows; r++) {
    for (let c = 0; c < numCols; c++) {
      const pr = r % pattern.rows;
      const pc = c % pattern.cols;

      const baseExisting = existing.grid[r] && existing.grid[r][c] ? existing.grid[r][c] : {};
      const basePattern =
        pattern.grid[pr] && pattern.grid[pr][pc]
          ? pattern.grid[pr][pc]
          : {};
      const merged = mergeBordersCell(baseExisting, basePattern);

      const topFromAbove = aboveGrid && aboveGrid[0] && aboveGrid[0][c] && aboveGrid[0][c].bottom
        ? aboveGrid[0][c].bottom
        : null;
      const bottomFromBelow = belowGrid && belowGrid[0] && belowGrid[0][c] && belowGrid[0][c].top
        ? belowGrid[0][c].top
        : null;

      if (topFromAbove || merged.top) {
        merged.top = pickStrongerBorder(topFromAbove, merged.top || null) || merged.top || topFromAbove || null;
      }
      if (bottomFromBelow || merged.bottom) {
        merged.bottom =
          pickStrongerBorder(bottomFromBelow, merged.bottom || null) ||
          merged.bottom ||
          bottomFromBelow ||
          null;
      }

      const fields = buildBordersFields_(merged);
      if (!fields) continue;

      requests.push({
        updateCells: {
          range: {
            sheetId: sheetId,
            startRowIndex: startRow - 1 + r,
            endRowIndex: startRow - 1 + r + 1,
            startColumnIndex: startCol - 1 + c,
            endColumnIndex: startCol - 1 + c + 1
          },
          rows: [{ values: [{ userEnteredFormat: { borders: merged } }] }],
          fields: fields
        }
      });
    }
  }

  if (requests.length) {
    Sheets.Spreadsheets.batchUpdate({ requests: requests }, ss.getId());
  }
}

/* =========================
 * onEdit Ìä∏Î¶¨Í±∞
 * ========================= */

function onEdit(e) {
  formatTitleLinesBoldUnderline(e);
}
