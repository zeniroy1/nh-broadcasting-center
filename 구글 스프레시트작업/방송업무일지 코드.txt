/**
 * NonAuto_Utilities_Anchored_Complete.gs
 */

const AUTO_FMT = {
  ENABLED_SHEETS: ['ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ'],
  TARGET_COLUMN: 5,
  ANCHOR_TEXT: 'ì¤‘ìš”ë³´ê³ ì‚¬í•­',
  TARGET_NAMED_RANGE: 'ìë™ì„œì‹_ëŒ€ìƒ',
  EXCLUDE_NAMED_RANGE: 'ìë™ì„œì‹_ì˜ˆì™¸'
};

const PDF_EXPORT = {
  START_SHEET: 'ì›”',
  END_SHEET_EXCLUSIVE: '4p',
  FILE_PREFIX: 'ë°©ì†¡ì—…ë¬´ì¼ì§€',
  FOLDER_ID: '16VUeThhNUT7PGNb-RXAwR3Mz4vwhhwtX?hl=ko',
  EXCLUDE_SHEETS: ['6p', 'ì…ë ¥', 'ë©”ëª¨', 'memo'],
  EXCLUDE_NAMED_RANGE: '',
  EXCLUDE_NAME_REGEX: '',
  SKIP_EMPTY_SHEETS: false,
  IMAGE_RENDER_WAIT_MS: 4000
};

/* =========================
 * ê³µí†µ í—¬í¼
 * ========================= */

function _isCellInRange_(rng, cell) {
  if (!rng) return false;
  if (rng.getSheet().getSheetId() !== cell.getSheet().getSheetId()) return false;
  return (
    cell.getRow() >= rng.getRow() &&
    cell.getRow() <= rng.getLastRow() &&
    cell.getColumn() >= rng.getColumn() &&
    cell.getColumn() <= rng.getLastColumn()
  );
}

function _findAnchorRowByText_(sheet, text) {
  if (!text) return null;
  const lastRow = Math.max(1, sheet.getLastRow());
  const lastCol = Math.max(1, Math.min(15, sheet.getLastColumn()));
  if (lastRow === 0) return null;
  const grid = sheet.getRange(1, 1, lastRow, lastCol).getDisplayValues();
  for (let r = 0; r < grid.length; r++) {
    for (let c = 0; c < grid[r].length; c++) {
      if (String(grid[r][c] || '').indexOf(text) !== -1) return r + 1;
    }
  }
  return null;
}

function sleepMs_(ms) {
  try {
    Utilities.sleep(ms);
  } catch (_) {}
}

function fetchPdfOrThrow_(url) {
  const token = ScriptApp.getOAuthToken();
  const res = UrlFetchApp.fetch(url, {
    headers: { Authorization: 'Bearer ' + token },
    muteHttpExceptions: true,
    followRedirects: true
  });
  const code = res.getResponseCode();
  const blob = res.getBlob();
  const headers = res.getHeaders();
  const ct = String(headers && headers['Content-Type'] ? headers['Content-Type'] : (blob.getContentType() || ''));
  const size = blob.getBytes().length;

  if (code !== 200) throw new Error('PDF ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨ - HTTP ' + code);

  const looksPdf = /application\/pdf/i.test(ct) || /\.pdf$/i.test(String(blob.getName() || ''));
  if (!looksPdf || size < 1024) {
    Logger.log('Unexpected PDF content: CT=' + ct + ', size=' + size + ', head=\n' + blob.getDataAsString().slice(0, 500));
    throw new Error('PDFê°€ ì•„ë‹Œ ì‘ë‹µ ë˜ëŠ” ë¹„ì •ìƒ íŒŒì¼(CT=' + ct + ', ' + size + 'B)');
  }
  return blob;
}

/* =========================
 * í´ë” ìœ í‹¸
 * ========================= */

function _extractPureFolderId_(input) {
  if (!input) return null;
  const s = String(input).trim();

  let m = s.match(/\/folders\/([A-Za-z0-9_-]{10,})/);
  if (m && m[1]) return m[1];

  m = s.match(/[?&]id=([A-Za-z0-9_-]{10,})/);
  if (m && m[1]) return m[1];

  const cleaned = s.replace(/[?#].*$/, '');
  if (/^[A-Za-z0-9_-]{10,}$/.test(cleaned)) return cleaned;

  return null;
}

function _assertFolderReachable_(folderId) {
  const f = DriveApp.getFolderById(folderId);
  f.getName();
  f.getId();
  return f;
}

function _resolveTargetFolderOrFallback_(ss) {
  const ui = SpreadsheetApp.getUi();
  const raw = (PDF_EXPORT.FOLDER_ID || '').trim();

  if (raw) {
    const pureId = _extractPureFolderId_(raw);
    if (!pureId) {
      ui.alert(
        'í´ë” ì§€ì • ê²½ê³ ',
        'FOLDER_IDì—ì„œ ìˆœìˆ˜ IDë¥¼ ì¶”ì¶œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\nì…ë ¥ê°’: ' + raw + '\nâ†’ URL ì „ì²´ê°€ ì•„ë‹ˆë¼, ìˆœìˆ˜ í´ë” IDë§Œ ì‚¬ìš©í•˜ì„¸ìš”.',
        ui.ButtonSet.OK
      );
    } else {
      try {
        return _assertFolderReachable_(pureId);
      } catch (e) {
        ui.alert('í´ë” ì ‘ê·¼ ë¶ˆê°€', 'ì§€ì • í´ë” ì ‘ê·¼ì— ì‹¤íŒ¨í•˜ì—¬ ê¸°ë³¸ ìœ„ì¹˜ì— ì €ì¥í•©ë‹ˆë‹¤.\nì‚¬ìœ : ' + e.message, ui.ButtonSet.OK);
      }
    }
  }

  const parents = DriveApp.getFileById(ss.getId()).getParents();
  return parents.hasNext() ? parents.next() : DriveApp.getRootFolder();
}

function testTargetFolderAccess() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const folder = _resolveTargetFolderOrFallback_(ss);
  const blob = Utilities.newBlob('folder-access-test', 'text/plain', 'access_test.txt');
  const f = folder.createFile(blob);
  f.setTrashed(true);
  SpreadsheetApp.getUi().alert('ì§€ì •/í´ë°± í´ë” ì ‘ê·¼ OK\ní´ë”ëª…: ' + folder.getName());
}

/* =========================
 * ì‹œíŠ¸ í¬í•¨/ì œì™¸ íŒì •
 * ========================= */

function getExcludedSheetNames_(ss) {
  const set = new Set();
  const base = (PDF_EXPORT.EXCLUDE_SHEETS || []).concat(['ë©”ëª¨', 'memo']);
  base.forEach(n => set.add(String(n).trim().toLowerCase()));

  const rn = PDF_EXPORT.EXCLUDE_NAMED_RANGE;
  if (rn && rn.trim() !== '') {
    const r = ss.getRangeByName(rn);
    if (r) {
      const vals = r.getDisplayValues();
      for (let i = 0; i < vals.length; i++) {
        for (let j = 0; j < vals[i].length; j++) {
          const v = String(vals[i][j]).trim().toLowerCase();
          if (v) set.add(v);
        }
      }
    }
  }
  return set;
}

function _containsMemoLike_(lowName) {
  if (lowName.indexOf('memo') !== -1) return true;
  if (lowName.replace(/\s+/g, '').indexOf('ë©”ëª¨') !== -1) return true;
  return false;
}

function shouldSkipSheetByNameString_(name) {
  const low = String(name || '').toLowerCase();
  if (_containsMemoLike_(low)) return true;
  if (low.indexOf('ì…ë ¥') !== -1) return true;
  if (low === '6p' || low.indexOf('6p') === 0) return true;
  if (low.indexOf('4p') === 0 && low.indexOf('ì…ë ¥') !== -1) return true;
  return false;
}

function shouldSkipSheet_(sheet, excludedSet) {
  const name = sheet.getName();
  const low = name.toLowerCase();

  if (shouldSkipSheetByNameString_(name)) return true;
  if (excludedSet.has(low)) return true;

  const pat = PDF_EXPORT.EXCLUDE_NAME_REGEX;
  if (pat && pat.trim() !== '') {
    try {
      if (new RegExp(pat).test(name)) return true;
    } catch (_) {}
  }

  if (PDF_EXPORT.SKIP_EMPTY_SHEETS) {
    const lr = Math.max(1, sheet.getLastRow());
    const lc = Math.max(1, sheet.getLastColumn());
    const grid = sheet.getRange(1, 1, lr, lc).getDisplayValues();
    let hasData = false;
    for (let r = 0; r < grid.length && !hasData; r++) {
      for (let c = 0; c < grid[r].length; c++) {
        if (String(grid[r][c]).trim() !== '') {
          hasData = true;
          break;
        }
      }
    }
    if (!hasData) return true;
  }
  return false;
}

function isWeekdaySheet_(name) {
  const low = String(name || '').toLowerCase().trim();
  return (low === 'ì›”' || low === 'í™”' || low === 'ìˆ˜' || low === 'ëª©' || low === 'ê¸ˆ');
}

function isPhotoSheet_(name) {
  const low = String(name || '').toLowerCase().trim();
  const startsWithWeekday = (
    low.indexOf('ì›”') === 0 ||
    low.indexOf('í™”') === 0 ||
    low.indexOf('ìˆ˜') === 0 ||
    low.indexOf('ëª©') === 0 ||
    low.indexOf('ê¸ˆ') === 0
  );
  return startsWithWeekday && !isWeekdaySheet_(name);
}

function matchStart_(name) {
  const start = String(PDF_EXPORT.START_SHEET || '').toLowerCase();
  const low = String(name || '').toLowerCase();
  return start && low.indexOf(start) === 0;
}

function isEndMarker_(name) {
  const end = String(PDF_EXPORT.END_SHEET_EXCLUSIVE || '').toLowerCase();
  const low = String(name || '').toLowerCase();
  return end && low.indexOf(end) === 0;
}

/* =========================
 * ë©”ë‰´ / ì˜¨ë³´ë”©
 * ========================= */

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  showWelcomeIfFirstRun_();

  ui.createMenu('ğŸ› ï¸ ìœ í‹¸ë¦¬í‹°')
    .addItem('ì„ íƒ ì˜ì—­ ê¸°ì¤€ í…Œë‘ë¦¬ ì ìš©', 'applyExactMasterBorders')
    .addSeparator()
    .addItem('ì‚¬ì§„ì—…ë¡œë“œ', 'automateFullImageProcess')
    .addSeparator()
    .addItem('ë³¸ê´€ì¼ì •ì •ë ¬', 'sortBongwanSchedule')
    .addItem('ì‹ ê´€ì¼ì •ì •ë ¬', 'sortSingwanSchedule')
    .addSeparator()
    .addItem('ì„ íƒì˜ì—­ í”½ì…€ í™•ì¸', 'getSelectionTotalSize')
    .addSeparator()
    .addItem('ì¸ì‡„ì˜ì—­ ì™¸ ì²­ì†Œ', 'cleanOutsidePrintArea')
    .addSeparator()
    .addItem('ğŸ“„ ì›”~4p PDF ì €ì¥ (í†µí•©)', 'exportPdfWithPreprocessing')
    .addSeparator()
    .addSubMenu(ui.createMenu('ğŸ”§ ê³ ê¸‰ ì˜µì…˜')
      .addItem('ì‚¬ì „ì‘ì—…(IMAGEâ†’ì˜¤ë²„ë ˆì´ ì¹˜í™˜)', 'replaceImageFunctionsOnActiveSheet_Overlay')
      .addItem('ì›”~4p PDF ì €ì¥(ì‚¬ì „ì‘ì—… ì œì™¸)', 'exportRangeToPdfBetweenMarkers'))
    .addSeparator()
    .addItem('êµ¬ê¸€ ë“œë¼ì´ë¸Œ í´ë” ì ‘ê·¼ í…ŒìŠ¤íŠ¸', 'testTargetFolderAccess')
    .addSeparator()
    .addItem('ë„ì›€ë§', 'showUtilityHelp')
    .addToUi();
}

function showWelcomeIfFirstRun_() {
  const props = PropertiesService.getDocumentProperties();
  const shown = props.getProperty('UTIL_WELCOME_SHOWN_V2');
  if (shown === '1') return;

  SpreadsheetApp.getUi().alert(
    'ğŸ‰ ì‹œíŠ¸ ê¸°ëŠ¥ ì²« ì‚¬ìš© ì•ˆë‚´',
    'ì²˜ìŒ ì‚¬ìš© ì‹œ ê¶Œí•œ ìš”ì²­ ì°½ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤. ì •ìƒ ë™ì‘ì„ ìœ„í•œ í•„ìˆ˜ ê³¼ì •ì…ë‹ˆë‹¤.',
    SpreadsheetApp.getUi().ButtonSet.OK
  );
  props.setProperty('UTIL_WELCOME_SHOWN_V2', '1');
}

function showUtilityHelp() {
  const ui = SpreadsheetApp.getUi();
  const title = 'ë„ì›€ë§';

  const intro = [
    'ë†í˜‘ë°©ì†¡ë‹¨ - ë°©ì†¡ì—…ë¬´ì¼ì§€',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'
  ];

  const utilityMenu = [
    '## ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° ë©”ë‰´',
    'ë©”ë‰´ â†’ [ğŸ› ï¸ ìœ í‹¸ë¦¬í‹°] í´ë¦­ í›„ ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥',
    '',
    'â€¢ ê¸°ì¤€ í…Œë‘ë¦¬ ì ìš©: ë¯¸ë¦¬ ì •í•´ì§„ ì–‘ì‹ì˜ í…Œë‘ë¦¬ë¥¼ ì„ íƒí•œ ì˜ì—­ì— í•œ ë²ˆì— ì ìš©',
    'â€¢ ì‚¬ì§„ ì—…ë¡œë“œ: êµ¬ê¸€ ë“œë¼ì´ë¸Œ ë§í¬ë§Œ ë¶™ì—¬ë„£ìœ¼ë©´ ì‹œíŠ¸ì— ì‚¬ì§„ì´ ìë™ ì—°ë™',
    'â€¢ ì¼ì • ì •ë ¬: íšŒì˜ì‹¤ ì‹œê°„Â·ì¥ì†Œ ìš°ì„ ìˆœìœ„ì— ë§ì¶° ì¼ì •ì„ ê¹”ë”í•˜ê²Œ ì •ë ¬',
    'â€¢ ì„ íƒì˜ì—­(ì…€) í”½ì…€ í™•ì¸: ì„ íƒ ì…€ì˜ ê°€ë¡œ ì„¸ë¡œ í”½ì…€ ìˆ˜ í™•ì¸',
    'â€¢ ì¸ì‡„ ì˜ì—­ ì™¸ ì²­ì†Œ: ë¶ˆí•„ìš”í•œ ì˜ì—­ì˜ ë°ì´í„°ì™€ ì„œì‹ì„ ëª¨ë‘ ì‚­ì œí•˜ì—¬ ì‹œíŠ¸ ì •ë¦¬',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'
  ];

  const autoInsert = [
    '## âœ¨ ìë™ í–‰ì‚½ì… ê¸°ëŠ¥',
    'í‘œ ì¤‘ê°„ì— ìƒˆë¡œìš´ í–‰ ì¶”ê°€ ì‹œ, ìƒˆë¡œìš´ í–‰ì— í…Œë‘ë¦¬ ìë™ ì ìš©',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'
  ];

  const autoFormat = [
    '## âœï¸ ìë™ ì™„ì„± ê¸°ëŠ¥',
    'ì…€ì— ë‚´ìš©ì„ ì…ë ¥í•˜ë©´ íŠ¹ì • í‚¤ì›Œë“œì— ë”°ë¼ ìë™ìœ¼ë¡œ ì„œì‹ì´ ì ìš©',
    'ì •í™•ì„±ì„ ë†’ì´ê¸° ìœ„í•´ ( ) ê´„í˜¸ë¥¼ í¬í•¨í•œ ë‹¨ì–´ë§Œ ì ìš©',
    '',
    'â€¢ (íšŒì¥) í¬í•¨ ì‹œ â†’ í•´ë‹¹ ì¤„ ì „ì²´ â˜… + êµµê²Œ + ë°‘ì¤„',
    '  (ë‹¨, ë¶€íšŒì¥, ê¸ˆìœµì§€ì£¼íšŒì¥ì€ ì œì™¸)',
    '',
    'â€¢ (ë¶€íšŒì¥) í¬í•¨ ì‹œ â†’ í•´ë‹¹ ì¤„ ì „ì²´ êµµê²Œ + ë°‘ì¤„',
    '',
    'â€¢ (ê¸ˆìœµì§€ì£¼íšŒì¥), (ì€í–‰ì¥), (ìƒí˜¸ê¸ˆìœµëŒ€í‘œ), (ì¶•ì‚°ê²½ì œëŒ€í‘œ), (ë†ì—…ê²½ì œëŒ€í‘œ), (ê°ì‚¬ìœ„ì›ì¥),(ì¡°í•©ê°ì‚¬ìœ„ì›ì¥),(ê²½ì œì§€ì£¼ëŒ€í‘œ) â†’ í•´ë‹¹ ì¤„ ì „ì²´ êµµê²Œ',
    '',
    'â€¢ êµ­ë¯¼ì˜ë¡€, ë…¹ìŒ, ë…¹í™” â†’ í•´ë‹¹ ë‹¨ì–´ë§Œ êµµê²Œ',
    '',
    'â€¢ íšŒì˜ ë‚´ìš©ì´ ê¸¸ ë•Œ ì¤„ë³„ í°íŠ¸ í¬ê¸°ë¥¼ ê°œë³„ ì¡°ì • ê°€ëŠ¥',
    '  (ì…€ ì „ì²´ ì„ íƒ í›„ í°íŠ¸ ë³€ê²½ ì‹œ ê°œë³„ í¬ê¸° ì´ˆê¸°í™”)',
    'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€',
    '',
    '## ğŸ› ï¸ PDF ì €ì¥ ê¸°ëŠ¥',
    'PDF íŒŒì¼ë¡œ ì›”~ê¸ˆ ì‹œíŠ¸ ë° ì‚¬ì§„ ì €ì¥',
    'â€¢ ì‚¬ì „ì‘ì—…: IMAGE í•¨ìˆ˜ â†’ ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ë¡œ ì¹˜í™˜(í˜„ì¬ ì‹œíŠ¸)',
    'â€¢ ì›” ì‹œíŠ¸~4p ì‚¬ì´ PDF ì €ì¥(íŒŒì¼ëª…: ë°©ì†¡ì—…ë¬´ì¼ì§€(MM.DD~MM.DD).pdf)'
  ];

  const message = [...intro, '', ...utilityMenu, '', ...autoInsert, '', ...autoFormat].join('\n');
  ui.alert(title, message, ui.ButtonSet.OK);
}

/* =========================
 * ë³´ë” ìœ í‹¸
 * ========================= */

const BORDER_PRIORITY = {
  DOTTED: 1,
  DASHED: 2,
  SOLID: 3,
  SOLID_MEDIUM: 4,
  SOLID_THICK: 5,
  DOUBLE: 6
};

function pickStrongerBorder(existingSide, incomingSide) {
  const hasExisting = !!existingSide;
  const hasIncoming = !!incomingSide;
  if (!hasExisting && !hasIncoming) return null;
  if (hasExisting && !hasIncoming) return existingSide;
  if (!hasExisting && hasIncoming) return incomingSide;

  const es = BORDER_PRIORITY[String((existingSide && existingSide.style) || '')] || 0;
  const ns = BORDER_PRIORITY[String((incomingSide && incomingSide.style) || '')] || 0;
  return es >= ns ? existingSide : incomingSide;
}

function mergeBordersCell(existing, incoming) {
  const out = {};
  const ex = existing || {};
  const inc = incoming || {};
  ['top', 'bottom', 'left', 'right'].forEach(s => {
    const chosen = pickStrongerBorder(ex[s] || null, inc[s] || null);
    if (chosen) out[s] = chosen;
  });
  return out;
}

/* =========================
 * ê¸°ì¤€/ê¸°ì¡´ ë³´ë” ì½ê¸°
 * ========================= */

function MasterBorders_fetchPatternGrid_(ss) {
  try {
    const master = ss.getRangeByName('ê¸°ì¤€ì„œì‹');
    if (!master) {
      SpreadsheetApp.getUi().alert(
        'ì´ë¦„ë²”ìœ„ "ê¸°ì¤€ì„œì‹"ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\nì‹œì‹ì‹œíŠ¸!B8:G8ì„ ì§€ì •í•´ ì£¼ì„¸ìš”.',
        SpreadsheetApp.getUi().ButtonSet.OK
      );
      return null;
    }

    const res = Sheets.Spreadsheets.get(ss.getId(), {
      ranges: master.getSheet().getName() + '!' + master.getA1Notation(),
      fields: 'sheets.data.rowData.values.userEnteredFormat.borders'
    });

    const rows = master.getNumRows();
    const cols = master.getNumColumns();
    const rowData =
      res && res.sheets && res.sheets[0] && res.sheets[0].data && res.sheets[0].data[0]
        ? res.sheets[0].data[0].rowData || []
        : [];
    const grid = [];

    for (let r = 0; r < rows; r++) {
      const values = rowData[r] && rowData[r].values ? rowData[r].values : [];
      const line = [];
      for (let c = 0; c < cols; c++) {
        const fmt = values[c] && values[c].userEnteredFormat ? values[c].userEnteredFormat : {};
        line.push((fmt && fmt.borders) ? fmt.borders : {});
      }
      grid.push(line);
    }
    return { rows: rows, cols: cols, grid: grid };
  } catch (err) {
    Logger.log('[MasterBorders_fetchPatternGrid_] ' + (err.stack || err));
    return null;
  }
}

function fetchExistingBordersGrid_(sheet, range) {
  const ss = sheet.getParent();
  const res = Sheets.Spreadsheets.get(ss.getId(), {
    ranges: sheet.getName() + '!' + range.getA1Notation(),
    fields: 'sheets.data.rowData.values.userEnteredFormat.borders'
  });

  const rows = range.getNumRows();
  const cols = range.getNumColumns();
  const rowData =
    res && res.sheets && res.sheets[0] && res.sheets[0].data && res.sheets[0].data[0]
      ? res.sheets[0].data[0].rowData || []
      : [];
  const grid = [];

  for (let r = 0; r < rows; r++) {
    const values = rowData[r] && rowData[r].values ? rowData[r].values : [];
    const line = [];
    for (let c = 0; c < cols; c++) {
      const fmt = values[c] && values[c].userEnteredFormat ? values[c].userEnteredFormat : {};
      line.push((fmt && fmt.borders) ? fmt.borders : {});
    }
    grid.push(line);
  }
  return { rows: rows, cols: cols, grid: grid };
}

/* =========================
 * ê¸°ì¤€ í…Œë‘ë¦¬ ë³µì œ(ì„ íƒì˜ì—­)
 * ========================= */

function applyExactMasterBorders() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const rng = sheet.getActiveRange();
  if (!rng) {
    ui.alert('ì•Œë¦¼', 'ë¨¼ì € í…Œë‘ë¦¬ë¥¼ ì ìš©í•  ì˜ì—­ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', ui.ButtonSet.OK);
    return;
  }

  const pattern = MasterBorders_fetchPatternGrid_(ss);
  if (!pattern) {
    ui.alert('ì•Œë¦¼', 'ì´ë¦„ë²”ìœ„ "ê¸°ì¤€ì„œì‹"(ì‹œì‹ì‹œíŠ¸!B8:G8)ì„ í™•ì¸í•˜ì„¸ìš”.', ui.ButtonSet.OK);
    return;
  }

  const mergedRanges = rng.getMergedRanges();
  const mergedSnaps = snapshotMergedTopEdges_(sheet, mergedRanges);
  rng.breakApart();

  const mergedCoord = [];
  mergedRanges.forEach(r => {
    for (let rr = r.getRow(); rr < r.getRow() + r.getNumRows(); rr++) {
      for (let cc = r.getColumn(); cc < r.getColumn() + r.getNumColumns(); cc++) {
        mergedCoord.push(rr + ',' + cc);
      }
    }
  });

  const existing = fetchExistingBordersGrid_(sheet, rng);
  const sheetId = sheet.getSheetId();
  const sr = rng.getRow() - 1;
  const sc = rng.getColumn() - 1;
  const nr = rng.getNumRows();
  const nc = rng.getNumColumns();

  const requests = [];
  for (let r = 0; r < nr; r++) {
    for (let c = 0; c < nc; c++) {
      const pr = r % pattern.rows;
      const pc = c % pattern.cols;
      const baseExisting = existing.grid[r] && existing.grid[r][c] ? existing.grid[r][c] : {};
      const basePattern =
        pattern.grid[pr] && pattern.grid[pr][pc]
          ? pattern.grid[pr][pc]
          : {};
      const mergedBorders = mergeBordersCell(baseExisting, basePattern);

      const absRow = rng.getRow() + r;
      const absCol = rng.getColumn() + c;
      const inMerged = mergedCoord.indexOf(absRow + ',' + absCol) !== -1;

      const fields = inMerged
        ? buildBordersFieldsSkipTop_(mergedBorders)
        : buildBordersFields_(mergedBorders);
      if (!fields) continue;

      requests.push({
        updateCells: {
          range: {
            sheetId: sheetId,
            startRowIndex: sr + r,
            endRowIndex: sr + r + 1,
            startColumnIndex: sc + c,
            endColumnIndex: sc + c + 1
          },
          rows: [{ values: [{ userEnteredFormat: { borders: mergedBorders } }] }],
          fields: fields
        }
      });
    }
  }

  if (requests.length) {
    Sheets.Spreadsheets.batchUpdate({ requests: requests }, ss.getId());
  }

  mergedRanges.forEach(r => {
    sheet.getRange(r.getRow(), r.getColumn(), r.getNumRows(), r.getNumColumns()).merge();
  });

  if (mergedSnaps.length) {
    const fixRequests = [];
    mergedSnaps.forEach(s => {
      if (!s.top) return;
      fixRequests.push({
        updateBorders: {
          range: {
            sheetId: sheetId,
            startRowIndex: s.row - 1,
            endRowIndex: s.row - 1 + s.nr,
            startColumnIndex: s.col - 1,
            endColumnIndex: s.col - 1 + s.nc
          },
          top: s.top
        }
      });
    });
    if (fixRequests.length) {
      Sheets.Spreadsheets.batchUpdate({ requests: fixRequests }, ss.getId());
    }
  }
}

function buildBordersFields_(bordersObj) {
  if (!bordersObj) return '';
  const parts = [];
  if (bordersObj.top) parts.push('userEnteredFormat.borders.top');
  if (bordersObj.bottom) parts.push('userEnteredFormat.borders.bottom');
  if (bordersObj.left) parts.push('userEnteredFormat.borders.left');
  if (bordersObj.right) parts.push('userEnteredFormat.borders.right');
  return parts.length ? parts.join(',') : '';
}

function buildBordersFieldsSkipTop_(bordersObj) {
  if (!bordersObj) return '';
  const parts = [];
  if (bordersObj.bottom) parts.push('userEnteredFormat.borders.bottom');
  if (bordersObj.left) parts.push('userEnteredFormat.borders.left');
  if (bordersObj.right) parts.push('userEnteredFormat.borders.right');
  return parts.length ? parts.join(',') : '';
}

function snapshotMergedTopEdges_(sheet, mergedRanges) {
  const snaps = [];
  mergedRanges.forEach(r => {
    const row = r.getRow();
    const col = r.getColumn();
    const nr = r.getNumRows();
    const nc = r.getNumColumns();
    const grid = fetchExistingBordersGrid_(sheet, r).grid;
    const top = strongestTopOnGrid_(grid);
    snaps.push({ row: row, col: col, nr: nr, nc: nc, top: top });
  });
  return snaps;
}

function strongestTopOnGrid_(grid) {
  let chosen = null;
  const rows = grid.length;
  const cols = rows ? grid[0].length : 0;
  if (!rows || !cols) return null;
  for (let c = 0; c < cols; c++) {
    const cand = grid[0][c] && grid[0][c].top ? grid[0][c].top : null;
    chosen = pickStrongerBorder(chosen, cand);
  }
  return chosen;
}

/* =========================
 * ì„ íƒ ì˜ì—­ í¬ê¸° í™•ì¸
 * ========================= */

function getSelectionTotalSize() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const selection = sheet.getActiveRange();
  if (!selection) {
    ui.alert('ì•Œë¦¼', 'ë¨¼ì € í¬ê¸°ë¥¼ í™•ì¸í•  ì…€ ì˜ì—­ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', ui.ButtonSet.OK);
    return;
  }

  const startRow = selection.getRow();
  const endRow = selection.getLastRow();
  const startCol = selection.getColumn();
  const endCol = selection.getLastColumn();

  let totalHeight = 0;
  for (let i = startRow; i <= endRow; i++) totalHeight += sheet.getRowHeight(i);

  let totalWidth = 0;
  for (let i = startCol; i <= endCol; i++) totalWidth += sheet.getColumnWidth(i);

  ui.alert(
    'ì„ íƒ ì˜ì—­ ì´ í¬ê¸°',
    'ë†’ì´: ' + totalHeight + '\në„ˆë¹„: ' + totalWidth,
    ui.ButtonSet.OK
  );
}

/* =========================
 * ì¸ì‡„ì˜ì—­ ì™¸ë¶€ ì²­ì†Œ
 * ========================= */

function cleanOutsidePrintArea() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const selection = sheet.getActiveRange();

  let protectedLastRow;
  let protectedLastCol;
  let rangeDescription;

  if (selection && (selection.getNumRows() > 1 || selection.getNumColumns() > 1)) {
    protectedLastRow = selection.getLastRow();
    protectedLastCol = selection.getLastColumn();
    rangeDescription = 'ì„ íƒí•˜ì‹  ' + selection.getA1Notation();
  } else {
    protectedLastRow = 32;
    protectedLastCol = 8;
    rangeDescription = 'ê¸°ë³¸ ë²”ìœ„ì¸ A1:H32';
  }

  const maxRows = sheet.getMaxRows();
  const maxCols = sheet.getMaxColumns();

  if (maxRows > protectedLastRow) {
    sheet
      .getRange(protectedLastRow + 1, 1, maxRows - protectedLastRow, maxCols)
      .clear({ contentsOnly: true, formatOnly: true, commentsOnly: true, validationsOnly: true });
  }

  if (maxCols > protectedLastCol) {
    sheet
      .getRange(1, protectedLastCol + 1, protectedLastRow, maxCols - protectedLastCol)
      .clear({ contentsOnly: true, formatOnly: true, commentsOnly: true, validationsOnly: true });
  }

  ui.alert(
    'ì„±ê³µ',
    rangeDescription + ' ë²”ìœ„ë¥¼ ì œì™¸í•œ ëª¨ë“  ì™¸ë¶€ ì…€ì˜ ì„œì‹ê³¼ ë°ì´í„°ë¥¼ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.',
    ui.ButtonSet.OK
  );
}

/* =========================
 * ì¼ì • ì •ë ¬ (ì‹ ê´€/ë³¸ê´€)
 * ========================= */

function sortSingwanSchedule() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const userSelection = sheet.getActiveRange();
  if (!userSelection || userSelection.getNumRows() <= 1) return;

  const startRow = userSelection.getRow();
  const numRows = userSelection.getNumRows();
  const startCol = 3;
  const numCols = 5;
  const fullRangeToSort = sheet.getRange(startRow, startCol, numRows, numCols);

  const TIME_COL_INDEX = 0;
  const ROOM_COL_INDEX = 1;

  try {
    const roomPriority = {
      'ëŒ€íšŒì˜ì‹¤': 1,
      'ì¤‘íšŒì˜ì‹¤': 2,
      '1ì†ŒíšŒì˜ì‹¤': 3,
      '2ì†ŒíšŒì˜ì‹¤': 4,
      '3ì†ŒíšŒì˜ì‹¤': 5,
      'ê²½ì˜ì „ëµì‹¤': 6
    };
    sortHelper_(fullRangeToSort, roomPriority, TIME_COL_INDEX, ROOM_COL_INDEX);
  } catch (e) {
    Logger.log('ì‹ ê´€ ì •ë ¬ ì˜¤ë¥˜: ' + e.message);
    ui.alert('ì˜¤ë¥˜', 'ì‹ ê´€ ì¼ì • ì •ë ¬ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', ui.ButtonSet.OK);
  }
}

function sortBongwanSchedule() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const userSelection = sheet.getActiveRange();
  if (!userSelection || userSelection.getNumRows() <= 1) return;

  const startRow = userSelection.getRow();
  const numRows = userSelection.getNumRows();
  const startCol = 3;
  const numCols = 5;
  const fullRangeToSort = sheet.getRange(startRow, startCol, numRows, numCols);

  const TIME_COL_INDEX = 0;
  const ROOM_COL_INDEX = 1;

  try {
    const roomPriority = {
      'ëŒ€ê°•ë‹¹': 1,
      'ì¤‘íšŒì˜ì‹¤': 2,
      'í™”ìƒíšŒì˜ì‹¤': 3,
      'ì†ŒíšŒì˜ì‹¤': 4,
      'ì‹ í† ë¶ˆì´': 5,
      'ë‘ë ˆì‹ë‹¹': 6
    };
    sortHelper_(fullRangeToSort, roomPriority, TIME_COL_INDEX, ROOM_COL_INDEX);
  } catch (e) {
    Logger.log('ë³¸ê´€ ì •ë ¬ ì˜¤ë¥˜: ' + e.message);
    ui.alert('ì˜¤ë¥˜', 'ë³¸ê´€ ì¼ì • ì •ë ¬ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', ui.ButtonSet.OK);
  }
}

function sortHelper_(rangeToSort, roomPriority, timeIndex, roomIndex) {
  const sheet = rangeToSort.getSheet();
  const startRow = rangeToSort.getRow();
  const startCol = rangeToSort.getColumn();
  const numRows = rangeToSort.getNumRows();

  const E_COL_INDEX_IN_RANGE = 2;
  const eColumnRichText = sheet
    .getRange(startRow, startCol + E_COL_INDEX_IN_RANGE, numRows, 1)
    .getRichTextValues();

  const fullFormats = {
    values: rangeToSort.getValues(),
    displayValues: rangeToSort.getDisplayValues(),
    numberFormats: rangeToSort.getNumberFormats(),
    backgrounds: rangeToSort.getBackgrounds(),
    horizontalAlignments: rangeToSort.getHorizontalAlignments(),
    wrapStrategies: rangeToSort.getWrapStrategies(),
    notes: rangeToSort.getNotes()
  };

  const data = [];
  for (let i = 0; i < numRows; i++) {
    data.push({
      timeKey: fullFormats.displayValues[i][timeIndex],
      roomKey: fullFormats.displayValues[i][roomIndex] || '',
      eColumnRichText: eColumnRichText[i][0],
      otherData: {
        values: fullFormats.values[i],
        numberFormats: fullFormats.numberFormats[i],
        backgrounds: fullFormats.backgrounds[i],
        horizontalAlignments: fullFormats.horizontalAlignments[i],
        wrapStrategies: fullFormats.wrapStrategies[i],
        notes: fullFormats.notes[i]
      }
    });
  }

  const toSort = data.filter(r => r.timeKey && r.timeKey.trim() !== '');
  const notToSort = data.filter(r => !r.timeKey || r.timeKey.trim() === '');

  toSort.sort((a, b) => {
    const pa = a.timeKey.split('~');
    const pb = b.timeKey.split('~');
    const sa = new Date('1970/01/01 ' + pa[0].trim());
    const sb = new Date('1970/01/01 ' + pb[0].trim());
    const ea = new Date('1970/01/01 ' + (pa[1] || pa[0]).trim());
    const eb = new Date('1970/01/01 ' + (pb[1] || pb[0]).trim());
    const aIs = !isNaN(sa.getTime());
    const bIs = !isNaN(sb.getTime());

    if (aIs && bIs) {
      const s = sa - sb;
      if (s !== 0) return s;
      const e = ea - eb;
      if (e !== 0) return e;
      const pao = roomPriority[a.roomKey.trim()] || 99;
      const pbo = roomPriority[b.roomKey.trim()] || 99;
      return pao - pbo;
    }
    return a.timeKey.localeCompare(b.timeKey);
  });

  const sorted = toSort.concat(notToSort);
  const newE = sorted.map(d => [d.eColumnRichText]);
  const newV = sorted.map(d => d.otherData.values);
  const newNF = sorted.map(d => d.otherData.numberFormats);
  const newBg = sorted.map(d => d.otherData.backgrounds);
  const newHA = sorted.map(d => d.otherData.horizontalAlignments);
  const newWS = sorted.map(d => d.otherData.wrapStrategies);
  const newNt = sorted.map(d => d.otherData.notes);

  rangeToSort
    .setValues(newV)
    .setNumberFormats(newNF)
    .setBackgrounds(newBg)
    .setHorizontalAlignments(newHA)
    .setVerticalAlignment('middle')
    .setWrapStrategies(newWS)
    .setNotes(newNt);

  sheet
    .getRange(startRow, startCol + E_COL_INDEX_IN_RANGE, numRows, 1)
    .setRichTextValues(newE);
}

/* =========================
 * í‚¤ì›Œë“œ ìë™ ì„œì‹ (ì¤„ë³„ í°íŠ¸ í¬ê¸° ë³´ì¡´)
 * ========================= */

function _computeLineBoundaries_(text) {
  const lines = String(text || '').split('\n');
  const bounds = [];
  let idx = 0;
  for (let i = 0; i < lines.length; i++) {
    const start = idx;
    const end = idx + lines[i].length;
    bounds.push({ start: start, end: end });
    idx = end + 1;
  }
  return bounds;
}

function _inferPerLineFontSizes_(rt) {
  if (!rt) return [];
  const text = rt.getText();
  const lines = _computeLineBoundaries_(text);
  if (!lines.length) return [];

  const runs = rt.getRuns() || [];
  const weights = lines.map(() => Object.create(null));

  runs.forEach(run => {
    const s = run.getStartIndex();
    const e = run.getEndIndex();
    const style = run.getTextStyle && run.getTextStyle();
    const sz = style && typeof style.getFontSize === 'function' ? style.getFontSize() : null;
    if (sz == null) return;

    for (let li = 0; li < lines.length; li++) {
      const L = lines[li];
      const overlap = Math.max(0, Math.min(e, L.end) - Math.max(s, L.start));
      if (overlap > 0) {
        weights[li][sz] = (weights[li][sz] || 0) + overlap;
      }
    }
  });

  return weights.map(w => {
    let bestSize = null;
    let bestW = -1;
    for (const k in w) {
      const size = Number(k);
      const ww = w[k];
      if (ww > bestW) {
        bestW = ww;
        bestSize = size;
      }
    }
    return bestSize;
  });
}

function formatTitleLinesBoldUnderline(e) {
  if (!e || !e.range || typeof e.value !== 'string') return;

  const cell = e.range;
  if (cell.getNumRows() > 1 || cell.getNumColumns() > 1) return;
  if (cell.getFormula()) return;

  const sheet = cell.getSheet();
  const ss = sheet.getParent();

  if (AUTO_FMT.ENABLED_SHEETS.indexOf(sheet.getName()) === -1) return;

  const excludeRng = ss.getRangeByName(AUTO_FMT.EXCLUDE_NAMED_RANGE);
  if (_isCellInRange_(excludeRng, cell)) return;

  const targetRng = ss.getRangeByName(AUTO_FMT.TARGET_NAMED_RANGE);
  if (targetRng) {
    if (!_isCellInRange_(targetRng, cell)) return;
  } else {
    if (cell.getColumn() !== AUTO_FMT.TARGET_COLUMN) return;
  }

  const anchorRow = _findAnchorRowByText_(sheet, AUTO_FMT.ANCHOR_TEXT);
  if (anchorRow && cell.getRow() >= anchorRow) return;

  const currentRT = cell.getRichTextValue();
  const originalText = currentRT ? currentRT.getText() : e.value.toString();

  const starKeywords = ['(íšŒì¥)'];
  const boldUnderlineKeywords = ['(ë¶€íšŒì¥)'];
  const boldOnlyKeywords = [
    '(ìƒí˜¸ê¸ˆìœµëŒ€í‘œ)',
    '(ì€í–‰ì¥)',
    '(ì¶•ì‚°ê²½ì œëŒ€í‘œ)',
    '(ë†ì—…ê²½ì œëŒ€í‘œ)',
    '(ê°ì‚¬ìœ„ì›ì¥)',
    '(ê¸ˆìœµì§€ì£¼íšŒì¥)',
    '(ì¡°í•©ê°ì‚¬ìœ„ì›ì¥)',
    '(ê²½ì œì§€ì£¼ëŒ€í‘œ)'
  ];
  const boldWordKeywords = ['êµ­ë¯¼ì˜ë¡€', 'ë…¹ìŒ', 'ë…¹í™”'];

  let lines = originalText.split('\n');

  lines = lines.map(line => {
    const hasStarTarget = starKeywords.some(kw => line.indexOf(kw) !== -1);
    if (hasStarTarget && line.indexOf('â˜…') !== 0) {
      return 'â˜…' + line;
    }
    return line;
  });

  const newText = lines.join('\n');

  let builder;
  if (currentRT && newText === originalText) {
    builder = currentRT.copy();
  } else {
    builder = SpreadsheetApp.newRichTextValue().setText(newText);

    const oldLineSizes = currentRT ? _inferPerLineFontSizes_(currentRT) : [];
    const newLineBounds = _computeLineBoundaries_(newText);

    for (let i = 0; i < newLineBounds.length; i++) {
      const size = oldLineSizes[i];
      if (size != null) {
        const L = newLineBounds[i];
        if (L.end > L.start) {
          builder.setTextStyle(
            L.start,
            L.end,
            SpreadsheetApp.newTextStyle().setFontSize(size).build()
          );
        }
      }
    }
  }

  const boldStyle = SpreadsheetApp.newTextStyle().setBold(true).build();
  const boldUnderlineStyle = SpreadsheetApp.newTextStyle().setBold(true).setUnderline(true).build();

  let cursor = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineLen = line.length;

    const applyRange = (style, from, to) => {
      const start = Math.max(0, from);
      const end = Math.min(lineLen, to);
      if (end > start) builder.setTextStyle(cursor + start, cursor + end, style);
    };

    if (line.indexOf('â˜…') === 0) {
      starKeywords.forEach(kw => {
        const idx = line.indexOf(kw);
        if (idx !== -1) {
          applyRange(boldUnderlineStyle, 0, idx + kw.length);
        }
      });
    }

    boldUnderlineKeywords.forEach(kw => {
      const idx = line.indexOf(kw);
      if (idx !== -1) {
        applyRange(boldUnderlineStyle, 0, idx + kw.length);
      }
    });

    boldOnlyKeywords.forEach(kw => {
      const idx = line.indexOf(kw);
      if (idx !== -1) {
        applyRange(boldStyle, 0, idx + kw.length);
      }
    });

    boldWordKeywords.forEach(word => {
      let idx = line.indexOf(word);
      while (idx !== -1) {
        applyRange(boldStyle, idx, idx + word.length);
        idx = line.indexOf(word, idx + word.length);
      }
    });

    cursor += lineLen + 1;
  }

  cell.setRichTextValue(builder.build());
}

/* =========================
 * ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì¦ˆ ìœ í‹¸
 * ========================= */

function getResizedBlobFromDrive_(fileId, targetW, targetH) {
  try {
    const w = Math.max(10, Math.floor(targetW));
    const h = Math.max(10, Math.floor(targetH));
    const url =
      'https://drive.google.com/thumbnail?authuser=0&sz=w' +
      w +
      '-h' +
      h +
      '&id=' +
      encodeURIComponent(fileId);
    const token = ScriptApp.getOAuthToken();
    const res = UrlFetchApp.fetch(url, {
      headers: { Authorization: 'Bearer ' + token },
      muteHttpExceptions: true,
      followRedirects: true
    });
    const code = res.getResponseCode();
    if (code !== 200) throw new Error('thumb HTTP ' + code);
    const blob = res.getBlob();
    const ct = blob.getContentType() || '';
    if (/text\/html/i.test(ct)) throw new Error('thumb HTML');
    return blob;
  } catch (e) {
    return DriveApp.getFileById(fileId).getBlob();
  }
}

function fitAndShrinkDriveImage_(fileId, targetW, targetH, maxBytes, maxPixels) {
  maxBytes = maxBytes || 2 * 1024 * 1024;
  maxPixels = maxPixels || 1000000;

  let blob = getResizedBlobFromDrive_(fileId, targetW, targetH);
  let factor = 1.0;

  for (let i = 0; i < 8; i++) {
    const bytes = blob.getBytes().length;
    const estPixels = Math.round(targetW * factor * (targetH * factor));
    if (bytes <= maxBytes && estPixels <= maxPixels) break;

    factor *= 0.85;
    const bw = Math.max(10, Math.floor(targetW * factor));
    const bh = Math.max(10, Math.floor(targetH * factor));
    blob = getResizedBlobFromDrive_(fileId, bw, bh);
  }

  return blob;
}

/* =========================
 * ì„ì‹œ íŒŒì¼ ì‚­ì œ ìœ í‹¸
 * ========================= */

function _hardDeleteFileOrTrashFallback_(fileId) {
  try {
    if (typeof Drive !== 'undefined' && Drive.Files && typeof Drive.Files.remove === 'function') {
      Drive.Files.remove(fileId);
      return true;
    }
  } catch (e) {
    Logger.log('Drive.Files.remove ì‹¤íŒ¨: ' + (e && e.message ? e.message : e));
  }
  try {
    DriveApp.getFileById(fileId).setTrashed(true);
    return false;
  } catch (e2) {
    Logger.log('DriveApp setTrashed ì‹¤íŒ¨: ' + (e2 && e2.message ? e2.message : e2));
    return false;
  }
}

/* =========================
 * PDF ì €ì¥(ì›”~4p ì§ì „)
 * ========================= */

/* ===== í†µí•© í•¨ìˆ˜: ì‚¬ì „ì‘ì—… + PDF ì €ì¥ì„ í•œ ë²ˆì— ìˆ˜í–‰ ===== */
function exportPdfWithPreprocessing() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();
  const excludeSet = getExcludedSheetNames_(ss);

  const namesToExport = [];
  let inRange = false;

  for (let i = 0; i < sheets.length; i++) {
    const s = sheets[i];
    const nm = s.getName();
    if (isEndMarker_(nm)) break;

    if (!inRange) {
      if (matchStart_(nm)) {
        inRange = true;
        if (!shouldSkipSheet_(s, excludeSet)) {
          namesToExport.push(nm);
        }
      }
      continue;
    }

    if (!shouldSkipSheet_(s, excludeSet)) {
      namesToExport.push(nm);
    }
  }

  if (namesToExport.length === 0) {
    ui.alert('ì•Œë¦¼', 'ì €ì¥í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë²”ìœ„/ì˜ˆì™¸ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.', ui.ButtonSet.OK);
    return;
  }

  const confirmResp = ui.alert(
    'PDF ì €ì¥',
    'PDF íŒŒì¼ì„ ì €ì¥í•©ë‹ˆë‹¤.\n\n' +
    'ï¿½ í¬í•¨ ì‹œíŠ¸: ' + namesToExport.join(', ') + '\n\n' +
    'ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
    ui.ButtonSet.OK_CANCEL
  );
  if (confirmResp !== ui.Button.OK) return;

  // PDF ì €ì¥
  const weekLabel = getWeekRangeLabelFromSheets_(ss);

  const temp = SpreadsheetApp.create('TEMP_PDF_' + Date.now());
  const tempId = temp.getId();
  const placeholder = temp.getActiveSheet().setName('_PLACEHOLDER_');

  const copied = [];
  namesToExport.forEach(nm => {
    const s = ss.getSheetByName(nm);
    if (!s) return;
    const c = s.copyTo(temp);
    try {
      c.setName(nm);
    } catch (_) {
      const ts = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'HHmmss');
      c.setName(nm + '_' + ts);
    }
    materializeDriveImagesWithCrossSheet_(c, ss);
    copied.push(c.getName());
  });

  if (temp.getSheets().length > 1) temp.deleteSheet(placeholder);

  const afterSheets = temp.getSheets();
  const namesToKeep = new Set(namesToExport.map(n => n.toLowerCase()));
  for (let i = 0; i < afterSheets.length; i++) {
    const s = afterSheets[i];
    const nm = s.getName();
    if (!namesToKeep.has(nm.toLowerCase()) || shouldSkipSheetByNameString_(nm)) {
      try {
        temp.deleteSheet(s);
      } catch (_) {}
    }
  }

  SpreadsheetApp.flush();
  sleepMs_(PDF_EXPORT.IMAGE_RENDER_WAIT_MS);

  const params = {
    format: 'pdf',
    size: 'A4',
    portrait: 'true',
    fitw: 'true',
    top_margin: '0.5',
    bottom_margin: '0.5',
    left_margin: '0.5',
    right_margin: '0.5',
    sheetnames: 'true',
    printtitle: 'false',
    pagenum: 'CENTER',
    gridlines: 'false',
    fzr: 'false',
    printnotes: 'false'
  };
  const query = Object.keys(params)
    .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))
    .join('&');
  const url = 'https://docs.google.com/spreadsheets/d/' + tempId + '/export?' + query;

  let blob;
  try {
    blob = fetchPdfOrThrow_(url);
  } catch (e1) {
    Logger.log('[Retry] ' + e1.message);
    SpreadsheetApp.flush();
    sleepMs_(1200);
    blob = fetchPdfOrThrow_(url);
  }

  const fname = (PDF_EXPORT.FILE_PREFIX || '') + '(' + weekLabel + ').pdf';
  blob.setName(fname);

  const folder = _resolveTargetFolderOrFallback_(ss);
  folder.createFile(blob);

  _hardDeleteFileOrTrashFallback_(tempId);

  ui.alert(
    'ì™„ë£Œ',
    'PDF ì €ì¥ ì™„ë£Œ!\n\n' +
      'í¬í•¨ ì‹œíŠ¸: ' + copied.join(', ') + '\n' +
      'íŒŒì¼ëª…: ' + fname + '\n' +
      'ì €ì¥ ìœ„ì¹˜: ' + folder.getName(),
    ui.ButtonSet.OK
  );
}

/* ===== ê°œë³„ ì‹œíŠ¸ ì˜¤ë²„ë ˆì´ ì¹˜í™˜ (ì‚¬ì „ì‘ì—…ìš© í—¬í¼) ===== */
function preprocessSheetOverlay_(sheet, ss) {
  const lr = sheet.getLastRow();
  const lc = sheet.getLastColumn();
  if (lr === 0 || lc === 0) return;

  const rg = sheet.getRange(1, 1, lr, lc);
  const formulas = rg.getFormulas();

  const RE_IMAGE = /(^|=|\W)IMAGE\s*\(/i;
  const RE_ID_PARAM = /[?&]id=([a-zA-Z0-9_-]{20,})/i;
  const RE_PATH_ID = /\/d\/([a-zA-Z0-9_-]{20,})(?:\/|$)/i;
  const RE_ANY_URL = /https?:\/\/[^\s")]+/gi;
  const RE_A1_ANY = /(?:'([^']+)'\s*!|([A-Za-z0-9_]+)\s*!|\b)(\$?[A-Z]+\$?\d+)\b/g;

  function pickIdFromString(s) {
    if (!s) return { id: null, url: null };
    const str = String(s);

    let m = str.match(RE_ID_PARAM);
    if (m && m[1]) return { id: m[1], url: null };

    m = str.match(RE_PATH_ID);
    if (m && m[1]) return { id: m[1], url: null };

    const urls = str.match(RE_ANY_URL) || [];
    for (let i = 0; i < urls.length; i++) {
      const u = urls[i];
      let k = u.match(RE_ID_PARAM);
      if (k && k[1]) return { id: k[1], url: u };
      k = u.match(RE_PATH_ID);
      if (k && k[1]) return { id: k[1], url: u };
    }

    const cleaned = str.replace(/["'+&=\s]/g, '');
    if (/^[a-zA-Z0-9_-]{20,}$/.test(cleaned)) return { id: cleaned, url: null };

    return { id: null, url: null };
  }

  function resolveA1RefsToValues(formula) {
    if (!formula) return '';
    return String(formula).replace(RE_A1_ANY, (m, qName1, name2, a1) => {
      try {
        if (qName1 || name2) {
          const name = qName1 ? qName1 : name2;
          const src = ss.getSheetByName(name);
          if (!src) return '';
          return src.getRange(a1).getDisplayValue();
        } else {
          return sheet.getRange(a1).getDisplayValue();
        }
      } catch (_) {
        return '';
      }
    });
  }

  function insertOverlay(a1, fileId, padPx) {
    const cell = sheet.getRange(a1);
    const box = cell.isPartOfMerge() ? cell.getMergedRanges()[0] : cell;
    const r0 = box.getRow();
    const c0 = box.getColumn();

    let w = 0;
    let h = 0;
    for (let c = c0; c < c0 + box.getNumColumns(); c++) w += sheet.getColumnWidth(c);
    for (let r = r0; r < r0 + box.getNumRows(); r++) h += sheet.getRowHeight(r);

    w = Math.max(10, w - (padPx || 0));
    h = Math.max(10, h - (padPx || 0));

    const blob = fitAndShrinkDriveImage_(fileId, w, h, 2 * 1024 * 1024, 1000000);
    const over = sheet.insertImage(blob, c0, r0);
    over.setWidth(Math.round(w));
    over.setHeight(Math.round(h));
    try {
      over.setAnchorCellXOffset(0);
      over.setAnchorCellYOffset(0);
    } catch (_) {}
    try {
      box.setValue('');
    } catch (_) {}
  }

  // ê¸°ì¡´ ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ ì œê±°
  try {
    sheet.getImages().forEach(img => {
      try { img.remove(); } catch (_) {}
    });
  } catch (_) {}

  // IMAGE ìˆ˜ì‹ â†’ ì˜¤ë²„ë ˆì´ ë³€í™˜
  for (let r = 0; r < lr; r++) {
    for (let c = 0; c < lc; c++) {
      const f = formulas[r][c];
      if (!f) continue;
      if (!RE_IMAGE.test(f)) continue;

      const a1 = sheet.getRange(r + 1, c + 1).getA1Notation();
      const resolved = resolveA1RefsToValues(f);
      let pick = pickIdFromString(resolved);

      if (!pick.id) pick = pickIdFromString(f);
      if (!pick.id) continue;

      try {
        insertOverlay(a1, pick.id, 2);
        sheet.getRange(a1).clearContent();
      } catch (e) {
        Logger.log('ì˜¤ë²„ë ˆì´ ì‚½ì… ì‹¤íŒ¨ (' + a1 + '): ' + e);
      }
    }
  }
}

function exportRangeToPdfBetweenMarkers() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();
  const excludeSet = getExcludedSheetNames_(ss);

  const namesToExport = [];
  let inRange = false;

  for (let i = 0; i < sheets.length; i++) {
    const s = sheets[i];
    const nm = s.getName();
    if (isEndMarker_(nm)) break;

    if (!inRange) {
      if (matchStart_(nm)) {
        inRange = true;
        if (isWeekdaySheet_(nm) && !shouldSkipSheet_(s, excludeSet)) namesToExport.push(nm);
      }
      continue;
    }

    if (isWeekdaySheet_(nm) && !shouldSkipSheet_(s, excludeSet)) namesToExport.push(nm);
  }

  if (namesToExport.length === 0) {
    ui.alert('ì•Œë¦¼', 'ì €ì¥í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë²”ìœ„/ì˜ˆì™¸ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.', ui.ButtonSet.OK);
    return;
  }

  const weekLabel = getWeekRangeLabelFromSheets_(ss);

  const temp = SpreadsheetApp.create('TEMP_PDF_' + Date.now());
  const tempId = temp.getId();
  const placeholder = temp.getActiveSheet().setName('_PLACEHOLDER_');

  const copied = [];
  namesToExport.forEach(nm => {
    const s = ss.getSheetByName(nm);
    if (!s) return;
    const c = s.copyTo(temp);
    try {
      c.setName(nm);
    } catch (_) {
      const ts = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'HHmmss');
      c.setName(nm + '_' + ts);
    }
    materializeDriveImagesWithCrossSheet_(c, ss);
    copied.push(c.getName());
  });

  if (temp.getSheets().length > 1) temp.deleteSheet(placeholder);

  const afterSheets = temp.getSheets();
  for (let i = 0; i < afterSheets.length; i++) {
    const s = afterSheets[i];
    const nm = s.getName();
    if (!isWeekdaySheet_(nm) || shouldSkipSheetByNameString_(nm)) {
      try {
        temp.deleteSheet(s);
      } catch (_) {}
    }
  }

  SpreadsheetApp.flush();
  sleepMs_(PDF_EXPORT.IMAGE_RENDER_WAIT_MS);

  const params = {
    format: 'pdf',
    size: 'A4',
    portrait: 'true',
    fitw: 'true',
    top_margin: '0.5',
    bottom_margin: '0.5',
    left_margin: '0.5',
    right_margin: '0.5',
    sheetnames: 'true',
    printtitle: 'false',
    pagenum: 'CENTER',
    gridlines: 'false',
    fzr: 'false',
    printnotes: 'false'
  };
  const query = Object.keys(params)
    .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))
    .join('&');
  const url = 'https://docs.google.com/spreadsheets/d/' + tempId + '/export?' + query;

  let blob;
  try {
    blob = fetchPdfOrThrow_(url);
  } catch (e1) {
    Logger.log('[Retry] ' + e1.message);
    SpreadsheetApp.flush();
    sleepMs_(1200);
    blob = fetchPdfOrThrow_(url);
  }

  const fname = (PDF_EXPORT.FILE_PREFIX || '') + '(' + weekLabel + ').pdf';
  blob.setName(fname);

  const folder = _resolveTargetFolderOrFallback_(ss);
  folder.createFile(blob);

  _hardDeleteFileOrTrashFallback_(tempId);

  ui.alert(
    'ì™„ë£Œ',
    'PDF ì €ì¥ ì™„ë£Œ\n\ní¬í•¨ ì‹œíŠ¸: ' +
      copied.join(', ') +
      '\níŒŒì¼ëª…: ' +
      fname +
      '\nì €ì¥ ìœ„ì¹˜: ' +
      folder.getName(),
    ui.ButtonSet.OK
  );
}

/* =========================
 * íŒŒì¼ëª… ìƒì„± ìœ í‹¸(E2 â†’ MM.DD~MM.DD)
 * ========================= */

function getWeekRangeLabelFromSheets_(ss) {
  function pad2(n) {
    n = Number(n);
    return (n < 10 ? '0' : '') + n;
  }

  function parseToMonthDay(text) {
    if (text == null) return null;
    const s = String(text).trim();
    if (!s) return null;

    let m = s.match(/(\d{4})[.\-\/](\d{1,2})[.\-\/](\d{1,2})/);
    if (m) return { m: pad2(m[2]), d: pad2(m[3]) };

    m = s.match(/(\d{1,2})[.\-\/](\d{1,2})/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    m = s.match(/(\d{1,2})\s*ì›”\s*(\d{1,2})\s*ì¼/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    m = s.match(/(\d{1,2})\s*[\.\-\/]\s*(\d{1,2})/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    m = s.match(/(\d{1,2})(\d{2})/);
    if (m) return { m: pad2(m[1]), d: pad2(m[2]) };

    const num = Number(s);
    if (!isNaN(num)) {
      const d = new Date(s);
      if (!isNaN(d.getTime())) return { m: pad2(d.getMonth() + 1), d: pad2(d.getDate()) };
    }
    return null;
  }

  function getE2MD(sheetName) {
    const sh = ss.getSheetByName(sheetName);
    if (!sh) return null;
    const v = sh.getRange('E2').getDisplayValue();
    return parseToMonthDay(v);
  }

  const fromMD = getE2MD('ì›”');
  const toMD = getE2MD('ê¸ˆ');
  const fromLabel = fromMD ? fromMD.m + '.' + fromMD.d : 'MM.DD';
  const toLabel = toMD ? toMD.m + '.' + toMD.d : 'MM.DD';
  return fromLabel + '~' + toLabel;
}

/* =========================
 * í˜„ì¬ ì‹œíŠ¸: IMAGE â†’ ì˜¤ë²„ë ˆì´ ì¹˜í™˜
 * ========================= */

function replaceImageFunctionsOnActiveSheet_Overlay() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSheet();
  const ss = sheet.getParent();

  const lr = sheet.getLastRow();
  const lc = sheet.getLastColumn();
  if (lr === 0 || lc === 0) {
    ui.alert('ì˜¤ë²„ë ˆì´ ì¹˜í™˜', 'ì‹œíŠ¸ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.', ui.ButtonSet.OK);
    return;
  }

  const rg = sheet.getRange(1, 1, lr, lc);
  const formulas = rg.getFormulas();

  const RE_IMAGE = /(^|=|\W)IMAGE\s*\(/i;
  const RE_ID_PARAM = /[?&]id=([a-zA-Z0-9_-]{20,})/i;
  const RE_PATH_ID = /\/d\/([a-zA-Z0-9_-]{20,})(?:\/|$)/i;
  const RE_ANY_URL = /https?:\/\/[^\s")]+/gi;
  const RE_A1_ANY = /(?:'([^']+)'\s*!|([A-Za-z0-9_]+)\s*!|\b)(\$?[A-Z]+\$?\d+)\b/g;

  function pickIdFromString(s) {
    if (!s) return { id: null, url: null };
    const str = String(s);

    let m = str.match(RE_ID_PARAM);
    if (m && m[1]) return { id: m[1], url: null };

    m = str.match(RE_PATH_ID);
    if (m && m[1]) return { id: m[1], url: null };

    const urls = str.match(RE_ANY_URL) || [];
    for (let i = 0; i < urls.length; i++) {
      const u = urls[i];
      let k = u.match(RE_ID_PARAM);
      if (k && k[1]) return { id: k[1], url: u };
      k = u.match(RE_PATH_ID);
      if (k && k[1]) return { id: k[1], url: u };
    }

    const cleaned = str.replace(/["'+&=\s]/g, '');
    if (/^[a-zA-Z0-9_-]{20,}$/.test(cleaned)) return { id: cleaned, url: null };

    return { id: null, url: null };
  }

  function resolveA1RefsToValues(formula) {
    if (!formula) return '';
    return String(formula).replace(RE_A1_ANY, (m, qName1, name2, a1) => {
      try {
        if (qName1 || name2) {
          const name = qName1 ? qName1 : name2;
          const src = ss.getSheetByName(name);
          if (!src) return '';
          return src.getRange(a1).getDisplayValue();
        } else {
          return sheet.getRange(a1).getDisplayValue();
        }
      } catch (_) {
        return '';
      }
    });
  }

  function collectA1Refs(formula) {
    const refs = [];
    if (!formula) return refs;
    String(formula).replace(RE_A1_ANY, (m, qName1, name2, a1) => {
      if (qName1 || name2) refs.push({ sheetName: qName1 ? qName1 : name2, a1: a1 });
      else refs.push({ sheetName: null, a1: a1 });
      return m;
    });
    return refs;
  }

  function insertOverlay(a1, fileId, padPx) {
    const cell = sheet.getRange(a1);
    const box = cell.isPartOfMerge() ? cell.getMergedRanges()[0] : cell;
    const r0 = box.getRow();
    const c0 = box.getColumn();

    let w = 0;
    let h = 0;
    for (let c = c0; c < c0 + box.getNumColumns(); c++) w += sheet.getColumnWidth(c);
    for (let r = r0; r < r0 + box.getNumRows(); r++) h += sheet.getRowHeight(r);

    w = Math.max(10, w - (padPx || 0));
    h = Math.max(10, h - (padPx || 0));

    const blob = fitAndShrinkDriveImage_(fileId, w, h, 2 * 1024 * 1024, 1000000);
    const over = sheet.insertImage(blob, c0, r0);
    over.setWidth(Math.round(w));
    over.setHeight(Math.round(h));
    try {
      over.setAnchorCell(r0, c0).setAnchorCellXOffset(0).setAnchorCellYOffset(0);
    } catch (_) {}
    try {
      box.setValue('');
    } catch (_) {}
  }

  try {
    sheet.getImages().forEach(img => {
      try {
        img.remove();
      } catch (_) {}
    });
  } catch (_) {}

  let nFound = 0;
  let nResolved = 0;
  let nInserted = 0;
  const debugLines = [];
  const fails = [];

  for (let r = 0; r < lr; r++) {
    for (let c = 0; c < lc; c++) {
      const f = formulas[r][c];
      if (!f) continue;
      if (!RE_IMAGE.test(f)) continue;

      const a1 = sheet.getRange(r + 1, c + 1).getA1Notation();
      nFound++;

      const resolved = resolveA1RefsToValues(f);
      let pick = pickIdFromString(resolved);

      const scannedRefs = [];
      if (!pick.id) {
        const refs = collectA1Refs(f);
        for (let i = 0; i < refs.length; i++) {
          const ref = refs[i];
          try {
            const rng = ref.sheetName
              ? ss.getSheetByName(ref.sheetName).getRange(ref.a1)
              : sheet.getRange(ref.a1);
            const val = rng.getDisplayValue();
            const p2 = pickIdFromString(val);
            scannedRefs.push((ref.sheetName ? "'" + ref.sheetName + "'!" : '') + ref.a1 + '=' + val);
            if (p2.id) {
              pick = p2;
              break;
            }
          } catch (_) {}
        }
      }

      if (pick.id) {
        nResolved++;
        try {
          insertOverlay(a1, pick.id, 2);
          sheet.getRange(a1).clearContent();
          nInserted++;
          debugLines.push('[OK] ' + a1 + '  id=' + pick.id);
        } catch (e) {
          fails.push(a1 + ' - ì‚½ì…ì‹¤íŒ¨: ' + e);
          debugLines.push('[ERR-INSERT] ' + a1 + '  id=' + pick.id + '  err=' + e);
        }
      } else {
        fails.push(a1 + ' - ID ë¯¸ê²€ì¶œ');
        debugLines.push(
          '[MISS] ' +
            a1 +
            '\n  formula: ' +
            f +
            '\n  resolved: ' +
            resolved +
            '\n  refScan: ' +
            scannedRefs.join(' | ')
        );
      }
    }
  }

  SpreadsheetApp.flush();
  Utilities.sleep(800);

  const headDetail = debugLines.slice(0, 20).join('\n');
  const summary = [
    'íƒì§€ëœ IMAGE ìˆ˜ì‹: ' + nFound + 'ê°œ',
    'ID í•´ì„ ì„±ê³µ: ' + nResolved + 'ê°œ',
    'ì˜¤ë²„ë ˆì´ ì‚½ì… ì„±ê³µ: ' + nInserted + 'ê°œ',
    fails.length
      ? '\nì‹¤íŒ¨ ëª©ë¡(ìš”ì•½):\n' +
        fails.slice(0, 10).join('\n') +
        (fails.length > 10 ? '\nâ€¦ì™¸ ' + (fails.length - 10) + 'ê±´' : '')
      : '',
    '\nìƒì„¸(ì¼ë¶€):\n' + headDetail
  ].join('\n');

  ui.alert('ì˜¤ë²„ë ˆì´ ì¹˜í™˜ ê²°ê³¼', summary, ui.ButtonSet.OK);
  Logger.log('==== Overlay Replace Detail ====\n' + debugLines.join('\n'));
}

/* =========================
 * ë³µì‚¬ë³¸ ì‹œíŠ¸: IMAGE â†’ ì˜¤ë²„ë ˆì´ ë³€í™˜
 * ========================= */

function materializeDriveImagesWithCrossSheet_(sheetCopy, originalSS) {
  const lr = sheetCopy.getLastRow();
  const lc = sheetCopy.getLastColumn();
  if (lr === 0 || lc === 0) return;

  const rg = sheetCopy.getRange(1, 1, lr, lc);
  const formulas = rg.getFormulas();
  const displays = rg.getDisplayValues();

  const anyImageCall = /(^|=|\W)IMAGE\s*\(/i;
  const idParamRegex = /id=([a-zA-Z0-9_-]{20,})/i;
  const filePathRegex = /\/d\/([a-zA-Z0-9_-]{20,})(?:\/|$)/i;

  function resolveCrossSheetRefs_(formula) {
    if (!formula) return '';
    const refRegex = /(?:'([^']+)'|([A-Za-z0-9_]+))?!([A-Z]+[0-9]+)|\b([A-Z]+[0-9]+)\b/g;
    return String(formula).replace(refRegex, (m, q1, s2, a1, a1Local) => {
      try {
        if (a1Local) {
          // [ìˆ˜ì •] Temp ë³µì‚¬ë³¸ì—ì„œ #REF! ì˜¤ë¥˜ê°€ ë‚  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì›ë³¸ ì‹œíŠ¸ ê°’ì„ ìš°ì„  ì°¸ì¡°
          const originalName = sheetCopy.getName();
           const srcSheet = originalSS.getSheetByName(originalName);
           if (srcSheet) {
             return String(srcSheet.getRange(a1Local).getDisplayValue() || '');
           }
          const v = sheetCopy.getRange(a1Local).getDisplayValue();
          return String(v || '');
        } else if (a1) {
          const sheetName = q1 ? q1 : s2;
          const srcSheet = originalSS.getSheetByName(sheetName);
          if (!srcSheet) return '';
          const v2 = srcSheet.getRange(a1).getDisplayValue();
          return String(v2 || '');
        }
        return '';
      } catch (_) {
        return '';
      }
    });
  }

  function detectDriveId_(textOrFormula) {
    if (!textOrFormula) return null;
    let s = String(textOrFormula);

    // 1. id=... íŒ¨í„´ ì‹œë„
    let m = s.match(idParamRegex);
    if (m && m[1]) return m[1];

    // 2. íŒŒì¼ ê²½ë¡œ /d/... íŒ¨í„´ ì‹œë„
    m = s.match(filePathRegex);
    if (m && m[1]) return m[1];

    // 3. ì •ì œ í›„ ID íŒ¨í„´ í™•ì¸ (ìˆœìˆ˜ IDì¸ ê²½ìš°)
    let cleaned = s.replace(/["'+&\s]/g, '');
    if (/^[a-zA-Z0-9_-]{20,}$/.test(cleaned)) return cleaned;

    // 4. [ì¶”ê°€] ì •ì œëœ ë¬¸ìì—´ ë‚´ì—ì„œ ê¸´ ID íŒ¨í„´ ê²€ìƒ‰ (ìˆ˜ì‹ ë‚´ ID ì¶”ì¶œ ê°•í™”)
    // ìˆ˜ì‹ì´ ë³µì¡í•˜ê²Œ ì„ì—¬ ìˆì„ ë•Œ ìœ ìš© (ì˜ˆ: =IMAGE("..."&"ID"))
    let m2 = cleaned.match(/([a-zA-Z0-9_-]{25,})/);
    if (m2 && m2[1]) return m2[1];

    return null;
  }

  function measureMergedPixelBox_(r, c) {
    const cell = sheetCopy.getRange(r + 1, c + 1);
    const mr = cell.isPartOfMerge() ? cell.getMergedRanges()[0] : cell;
    const rows = mr.getNumRows();
    const cols = mr.getNumColumns();

    let totalW = 0;
    let totalH = 0;
    for (let cc = mr.getColumn(); cc < mr.getColumn() + cols; cc++) {
      totalW += sheetCopy.getColumnWidth(cc);
    }
    for (let rr = mr.getRow(); rr < mr.getRow() + rows; rr++) {
      totalH += sheetCopy.getRowHeight(rr);
    }

    return {
      box: mr,
      pxW: Math.max(10, totalW - 2),
      pxH: Math.max(10, totalH - 2)
    };
  }

  let hasAnyImageFormula = false;
  for (let r0 = 0; r0 < formulas.length && !hasAnyImageFormula; r0++) {
    for (let c0 = 0; c0 < formulas[r0].length; c0++) {
      if (anyImageCall.test(formulas[r0][c0] || '')) {
        hasAnyImageFormula = true;
        break;
      }
    }
  }

  if (hasAnyImageFormula) {
    try {
      sheetCopy.getImages().forEach(img => {
        try {
          img.remove();
        } catch (_) {}
      });
    } catch (_) {}
  }

  if (hasAnyImageFormula) {
    for (let r = 0; r < formulas.length; r++) {
      for (let c = 0; c < formulas[r].length; c++) {
        let fileId = null;
        const f = formulas[r][c] || '';

        if (anyImageCall.test(f)) {
          const resolved = resolveCrossSheetRefs_(f);
          fileId = detectDriveId_(resolved);
        }
        // [ìˆ˜ì •] ìˆ˜ì‹ì´ ì—†ëŠ” ì¼ë°˜ í…ìŠ¤íŠ¸ ì…€(IDê°’ë§Œ ìˆëŠ” ì…€)ì€ ì´ë¯¸ì§€ ë³€í™˜ ëŒ€ìƒì—ì„œ ì œì™¸
        // if (!fileId) fileId = detectDriveId_(displays[r][c] || ''); 
        
        if (!fileId) continue;

        try {
          const m = measureMergedPixelBox_(r, c);
          let w = m.pxW;
          let h = m.pxH;
          const px = w * h;
          if (px > 1000000) {
            const s = Math.sqrt(1000000 / px);
            w = Math.max(10, Math.floor(w * s));
            h = Math.max(10, Math.floor(h * s));
          }
          const blob = fitAndShrinkDriveImage_(fileId, w, h, 2 * 1024 * 1024, 1000000);
          const over = sheetCopy.insertImage(blob, m.box.getColumn(), m.box.getRow());
          over.setWidth(Math.round(w));
          over.setHeight(Math.round(h));
          try {
            over
              .setAnchorCell(m.box.getRow(), m.box.getColumn())
              .setAnchorCellXOffset(0)
              .setAnchorCellYOffset(0);
          } catch (_) {}
          try {
            m.box.setValue('');
          } catch (_) {}
        } catch (_) {}
      }
    }
    SpreadsheetApp.flush();
    Utilities.sleep(1800);
  } else {
    SpreadsheetApp.flush();
    Utilities.sleep(1200);
  }
}

/* =========================
 * ì‚¬ì§„ ì—…ë¡œë“œ ìë™í™”
 * ========================= */

function automateFullImageProcess() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  try {
    const sheet = ss.getActiveSheet();
    const sname = sheet.getName().toLowerCase();

    if (sname === '4p' || sname === '6p') {
      const src = sheet.getRange('A1');
      const raw = String(src.getValue() || '').trim();
      if (raw) {
        const ids = getDriveIdsFromSource_(src);
        src.clearContent();
        if (ids.length === 0) {
          ui.alert('ì•Œë¦¼', 'A1ì—ì„œ ìœ íš¨í•œ Drive ë§í¬/IDë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.', ui.ButtonSet.OK);
          return;
        }
        if (applyIdsToTargetSheet_(sheet, ids)) {
          ui.alert('ì„±ê³µ', "'" + sheet.getName() + "' ì‹œíŠ¸ ì‚¬ì§„ ì—°ë™ ì™„ë£Œ!", ui.ButtonSet.OK);
        }
        return;
      }
    }

    const inputSheet = ss.getSheetByName('ì…ë ¥');
    if (inputSheet) {
      const box = inputSheet.getRange('B2');
      const raw = String(box.getValue() || '').trim();
      if (raw) {
        const resp = ui.prompt(
          'ì‚¬ì§„ ID ì—°ë™',
          'ë§í¬ë¥¼ ì ìš©í•  "ëŒ€ìƒ ì‹œíŠ¸ ì´ë¦„"ì„ ì…ë ¥í•˜ì„¸ìš”.',
          ui.ButtonSet.OK_CANCEL
        );
        if (resp.getSelectedButton() !== ui.Button.OK) return;

        const targetName = String(resp.getResponseText() || '').trim();
        if (!targetName) {
          ui.alert('ì˜¤ë¥˜', 'ì‹œíŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.', ui.ButtonSet.OK);
          return;
        }

        const target = ss.getSheetByName(targetName);
        if (!target) {
          ui.alert('ì˜¤ë¥˜', '"' + targetName + '" ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', ui.ButtonSet.OK);
          return;
        }

        const ids = getDriveIdsFromSource_(box);
        box.clearContent();
        if (ids.length === 0) {
          ui.alert('ì•Œë¦¼', "'ì…ë ¥'!B2ì—ì„œ ìœ íš¨í•œ ë§í¬/IDê°€ ì—†ìŠµë‹ˆë‹¤.", ui.ButtonSet.OK);
          return;
        }
        if (applyIdsToTargetSheet_(target, ids)) {
          ui.alert('ì„±ê³µ', "'" + target.getName() + "' ì‹œíŠ¸ ì‚¬ì§„ ì—°ë™ ì™„ë£Œ!", ui.ButtonSet.OK);
        }
        return;
      }
    }

    ui.alert(
      'ì•Œë¦¼',
      "ì²˜ë¦¬í•  ë§í¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n'4p'/'6p'!A1 ë˜ëŠ” 'ì…ë ¥'!B2ì— ë§í¬/IDë¥¼ ì…ë ¥í•˜ì„¸ìš”.",
      ui.ButtonSet.OK
    );
  } catch (e) {
    Logger.log('automateFullImageProcess ì˜¤ë¥˜: ' + (e && e.message ? e.message : e));
    SpreadsheetApp.getUi().alert('ì˜¤ë¥˜', 'ìë™í™” ê³¼ì • ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + e.message, ui.ButtonSet.OK);
  }
}

function getDriveIdsFromSource_(range) {
  const text = String(range.getValue() || '');
  if (!text.trim()) return [];
  const tokens = text
    .split(/[\s,;ã€€\t\n]+/)
    .map(s => s.trim())
    .filter(v => !!v);
  return tokens.map(extractValidDriveId_).filter(v => !!v);
}

function extractValidDriveId_(str) {
  if (typeof str !== 'string' || !str.trim()) return null;
  const s = str.trim();

  let m = s.match(/\/d\/([a-zA-Z0-9_-]{25,})/);
  if (m) return m[1];

  m = s.match(/[?&]id=([a-zA-Z0-9_-]{25,})/);
  if (m) return m[1];

  m = s.match(/^[a-zA-Z0-9_-]{25,40}$/);
  if (m) return s;

  return null;
}

function applyIdsToTargetSheet_(targetSheet, newIds) {
  const ui = SpreadsheetApp.getUi();
  const name = targetSheet.getName().toLowerCase();

  try {
    if (name === '4p' || name === '6p') {
      const map = {
        '4p': [
          { imgCell: 'A5', idCell: 'A7' },
          { imgCell: 'F5', idCell: 'F7' },
          { imgCell: 'A8', idCell: 'A10' },
          { imgCell: 'F8', idCell: 'F10' }
        ],
        '6p': [
          { imgCell: 'A4', idCell: 'A6' },
          { imgCell: 'F4', idCell: 'F6' },
          { imgCell: 'A7', idCell: 'A9' },
          { imgCell: 'F7', idCell: 'F9' },
          { imgCell: 'A10', idCell: 'A12' },
          { imgCell: 'F10', idCell: 'F12' }
        ]
      };

      const pairs = map[name];
      const idVals = pairs.map(p =>
        (targetSheet.getRange(p.idCell).getValue() || '').toString().trim()
      );
      const numNew = newIds.length;
      const numEmpty = idVals.filter(v => v === '').length;
      let start = 0;

      if (numEmpty > 0) {
        if (numNew <= numEmpty) {
          start = idVals.findIndex(v => v === '');
        } else {
          pairs.forEach(p => {
            targetSheet.getRange(p.idCell).clearContent();
            targetSheet.getRange(p.imgCell).clearContent();
          });
          start = 0;
        }
      } else {
        const n = Math.min(numNew, pairs.length);
        for (let i = 0; i < n; i++) {
          const p = pairs[i];
          targetSheet.getRange(p.idCell).clearContent();
          targetSheet.getRange(p.imgCell).clearContent();
        }
        start = 0;
      }

      newIds.forEach((id, i) => {
        const idx = start + i;
        if (idx < pairs.length) {
          const p = pairs[idx];
          targetSheet.getRange(p.idCell).setValue(id);
          targetSheet
            .getRange(p.imgCell)
            .setFormula('=IMAGE("https://drive.google.com/uc?export=download&id=" & ' + p.idCell + ', 2)');
        }
      });
      return true;
    }

    const lr = targetSheet.getLastRow();
    const lc = targetSheet.getLastColumn();
    if (lr === 0 || lc === 0) {
      ui.alert('ì•Œë¦¼', "'" + targetSheet.getName() + "' ì‹œíŠ¸ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.", ui.ButtonSet.OK);
      return false;
    }

    const re = /IMAGE\("https?:\/\/drive\.google\.com\/uc\?export=download&id=" *& *([A-Z]+\d+)\)/i;
    const formulas = targetSheet.getRange(1, 1, lr, lc).getFormulas();
    const refCells = [];

    for (let r = 0; r < formulas.length; r++) {
      for (let c = 0; c < formulas[r].length; c++) {
        const f = formulas[r][c] || '';
        const m = f.match(re);
        if (m && m[1]) refCells.push(m[1]);
      }
    }

    const unique = Array.from(new Set(refCells)).sort((a, b) => {
      const ra = parseInt(a.match(/\d+/)[0], 10);
      const rb = parseInt(b.match(/\d+/)[0], 10);
      return ra !== rb ? ra - rb : a.localeCompare(b);
    });

    if (unique.length === 0) {
      ui.alert(
        'ì˜¤ë¥˜',
        "'" + targetSheet.getName() + "' ì‹œíŠ¸ì—ì„œ IMAGE(\"...id=\" & A1) ìˆ˜ì‹ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.",
        ui.ButtonSet.OK
      );
      return false;
    }

    newIds.forEach((id, i) => {
      if (i < unique.length) targetSheet.getRange(unique[i]).setValue(id);
    });
    return true;
  } catch (e) {
    Logger.log(
      'applyIdsToTargetSheet_ ì˜¤ë¥˜(' +
        targetSheet.getName() +
        '): ' +
        (e && e.message ? e.message : e)
    );
    ui.alert(
      'ì˜¤ë¥˜',
      "'" + targetSheet.getName() + "' ì‹œíŠ¸ì— ID ì ìš© ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ui.ButtonSet.OK
    );
    return false;
  }
}

/* =========================
 * ìë™ í…Œë‘ë¦¬ (í–‰ ì‚½ì… íŠ¸ë¦¬ê±°ìš©)
 * ========================= */

function AutoBorderRows_setupTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  if (!triggers.some(t => t.getHandlerFunction() === 'AutoBorderRows_onChange')) {
    ScriptApp.newTrigger('AutoBorderRows_onChange')
      .forSpreadsheet(SpreadsheetApp.getActive())
      .onChange()
      .create();
    try {
      SpreadsheetApp.getUi().alert('ìë™ í…Œë‘ë¦¬ íŠ¸ë¦¬ê±°ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
    } catch (_) {}
  } else {
    try {
      SpreadsheetApp.getUi().alert('ì´ë¯¸ ìë™ í…Œë‘ë¦¬ íŠ¸ë¦¬ê±°ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.');
    } catch (_) {}
  }
}

function AutoBorderRows_removeTrigger() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === 'AutoBorderRows_onChange') {
      ScriptApp.deleteTrigger(t);
    }
  });
}

function isRowAnyBorder_(sheet, rowIndex) {
  if (rowIndex < 1 || rowIndex > sheet.getMaxRows()) return false;
  const range = sheet.getRange(rowIndex, 1, 1, sheet.getMaxColumns());
  const grid = fetchExistingBordersGrid_(sheet, range).grid;
  return grid[0].some(cellBorders => cellBorders && Object.keys(cellBorders).length > 0);
}

function AutoBorderRows_onChange(e) {
  if (!e || (e.changeType !== 'INSERT_ROW' && e.changeType !== 'INSERT_RANGE')) return;

  const ss = e.source;
  const sheet = ss.getActiveSheet();
  if (!sheet) return;

  Utilities.sleep(150);
  const ar = sheet.getActiveRange();
  if (!ar) return;

  const anchorRow = _findAnchorRowByText_(sheet, AUTO_FMT.ANCHOR_TEXT);
  if (anchorRow) {
    const firstInsertedRow = ar.getRow();
    const lastInsertedRow = ar.getLastRow();
    if (firstInsertedRow >= anchorRow || lastInsertedRow >= anchorRow) return;
  }

  const band = AutoBorderRows_resolveBandRange_(ss, sheet);
  if (!band) return;

  const firstInsertedRow = ar.getRow();
  const lastInsertedRow = ar.getLastRow();
  const aboveRowIndex = firstInsertedRow - 1;
  const belowRowIndex = lastInsertedRow + 1;

  if (aboveRowIndex < 1 || belowRowIndex > sheet.getMaxRows()) return;

  const aboveHas = isRowAnyBorder_(sheet, aboveRowIndex);
  const belowHas = isRowAnyBorder_(sheet, belowRowIndex);
  if (!(aboveHas && belowHas)) return;

  const pattern = MasterBorders_fetchPatternGrid_(ss);
  if (!pattern) return;

  const block = sheet.getRange(firstInsertedRow, band.getColumn(), ar.getNumRows(), band.getNumColumns());
  AutoBorderRows_paintRange_strongEdges_(sheet, block, band, pattern, aboveRowIndex, belowRowIndex);
}

function AutoBorderRows_resolveBandRange_(ss, sheet) {
  const name1 = 'ìë™í…Œë‘ë¦¬_ì—´ë²”ìœ„_' + sheet.getName();
  let r = ss.getRangeByName(name1);
  if (r && r.getSheet().getSheetId() === sheet.getSheetId()) return r;

  const name2 = 'ìë™í…Œë‘ë¦¬_ì—´ë²”ìœ„';
  r = ss.getRangeByName(name2);
  if (r && r.getSheet().getSheetId() === sheet.getSheetId()) return r;

  return null;
}

function AutoBorderRows_paintRange_strongEdges_(
  sheet,
  blockRange,
  band,
  pattern,
  aboveRowIndex,
  belowRowIndex
) {
  const ss = sheet.getParent();
  const sheetId = sheet.getSheetId();

  const numRows = blockRange.getNumRows();
  const numCols = band.getNumColumns();
  const startRow = blockRange.getRow();
  const startCol = band.getColumn();

  const rangeAbove = sheet.getRange(aboveRowIndex, startCol, 1, numCols);
  const rangeBelow = sheet.getRange(belowRowIndex, startCol, 1, numCols);

  const aboveGrid = fetchExistingBordersGrid_(sheet, rangeAbove).grid;
  const belowGrid = fetchExistingBordersGrid_(sheet, rangeBelow).grid;
  const existing = fetchExistingBordersGrid_(sheet, blockRange);

  const requests = [];

  for (let r = 0; r < numRows; r++) {
    for (let c = 0; c < numCols; c++) {
      const pr = r % pattern.rows;
      const pc = c % pattern.cols;

      const baseExisting = existing.grid[r] && existing.grid[r][c] ? existing.grid[r][c] : {};
      const basePattern =
        pattern.grid[pr] && pattern.grid[pr][pc]
          ? pattern.grid[pr][pc]
          : {};
      const merged = mergeBordersCell(baseExisting, basePattern);

      const topFromAbove = aboveGrid && aboveGrid[0] && aboveGrid[0][c] && aboveGrid[0][c].bottom
        ? aboveGrid[0][c].bottom
        : null;
      const bottomFromBelow = belowGrid && belowGrid[0] && belowGrid[0][c] && belowGrid[0][c].top
        ? belowGrid[0][c].top
        : null;

      if (topFromAbove || merged.top) {
        merged.top = pickStrongerBorder(topFromAbove, merged.top || null) || merged.top || topFromAbove || null;
      }
      if (bottomFromBelow || merged.bottom) {
        merged.bottom =
          pickStrongerBorder(bottomFromBelow, merged.bottom || null) ||
          merged.bottom ||
          bottomFromBelow ||
          null;
      }

      const fields = buildBordersFields_(merged);
      if (!fields) continue;

      requests.push({
        updateCells: {
          range: {
            sheetId: sheetId,
            startRowIndex: startRow - 1 + r,
            endRowIndex: startRow - 1 + r + 1,
            startColumnIndex: startCol - 1 + c,
            endColumnIndex: startCol - 1 + c + 1
          },
          rows: [{ values: [{ userEnteredFormat: { borders: merged } }] }],
          fields: fields
        }
      });
    }
  }

  if (requests.length) {
    Sheets.Spreadsheets.batchUpdate({ requests: requests }, ss.getId());
  }
}

/* =========================
 * onEdit íŠ¸ë¦¬ê±°
 * ========================= */

function onEdit(e) {
  formatTitleLinesBoldUnderline(e);
}
